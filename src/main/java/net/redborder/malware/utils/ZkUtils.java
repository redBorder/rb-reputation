package net.redborder.malware.utils;

        import org.apache.curator.framework.CuratorFramework;
        import org.apache.curator.framework.api.CuratorWatcher;
        import org.apache.curator.framework.recipes.leader.LeaderLatch;
        import org.apache.curator.framework.recipes.locks.InterProcessMutex;
        import org.apache.zookeeper.data.Stat;
        import org.codehaus.jackson.map.ObjectMapper;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;

        import java.io.IOException;
        import java.net.InetAddress;

public class ZkUtils {

    final Logger log = LoggerFactory.getLogger(ZkUtils.class);
    CuratorFramework curatorFramework;
    LeaderLatch latch;
    String zkWorkspace;
    String hostname;
    InterProcessMutex mutex;
    ObjectMapper objectMapper;

    public ZkUtils(CuratorFramework curatorFramework, String zkWorkspace) {
        this.curatorFramework = curatorFramework;
        this.zkWorkspace = zkWorkspace;
        this.objectMapper = new ObjectMapper();
        this.latch = new LeaderLatch(curatorFramework, zkWorkspace + "/latch");
        this.mutex = new InterProcessMutex(curatorFramework, zkWorkspace + "/working");


        try {
            this.hostname = InetAddress.getLocalHost().getHostName();
            latch.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public boolean isLeader() {
        return latch.hasLeadership();
    }

    public boolean checkExist(String zkPath) {

        boolean exist = false;

        try {
            exist = curatorFramework.checkExists().forPath(zkPath) != null;
        } catch (Exception e) {
            log.error("Can't register this node {}", hostname);
        }

        return exist;
    }

    public void registerNode() {
        try {
            String zkPath = zkWorkspace + "/workers/" + hostname;

            if (!checkExist(zkPath)) {
                curatorFramework.create().creatingParentsIfNeeded().forPath(zkPath, "0".getBytes());
            }

        } catch (Exception e) {
            log.error("Can't register this node {}", hostname);
        }
    }

    public void unRegisterNode() {
        try {
            String zkPath = zkWorkspace + "/workers/" + hostname;

            if (checkExist(zkPath)) {
                curatorFramework.delete().forPath(zkPath);
            }

        } catch (Exception e) {
            log.error("Can't unregister this node {}", hostname);
        }
    }


    public Integer incrementTask() {
        String zkPath = zkWorkspace + "/workers/" + hostname;
        Integer works = 0;
        try {
            byte[] data = curatorFramework.getData().forPath(zkPath);
            works = new Integer(new String(data));
            works++;
            curatorFramework.setData().forPath(zkPath, works.toString().getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }

        return works;
    }

    public void createChildIfNotExist(String child){

        try {
            if(!checkExist(String.format("%s/%s",zkWorkspace,child))) {
                log.info(String.format("Created new path : %s", curatorFramework.create().forPath(String.format("%s/%s", zkWorkspace, child))));
            }else
                log.info(String.format("Path \"%s/%s\" already exist!",zkWorkspace,child));
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public void setMutex() {
        try {
            log.info("Waiting on mutex. Other node is working ...");
            mutex.acquire();
            log.info("Setting mutex. Now, I'm working.");
        } catch (Exception e) {
            log.error("Can't setMutex");
        }
    }

    public void shutdown(){

        try {

            latch.close();
            releaseMutex();
            curatorFramework.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void releaseMutex() {
        try {
            mutex.release();
            log.info("Releasing mutex. Is time to relax.");
        } catch (Exception e) {
            log.error("Can't releaseMutex", hostname);
        }
    }

    public void watcherChildren(CuratorWatcher watcher, String zkPath) {
        try {
            curatorFramework.getChildren().usingWatcher(watcher).forPath(zkPath);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
