package net.redborder.malware.utils;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.recipes.leader.*;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.zookeeper.CreateMode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Map;

public class ZkUtils {

    private static final Logger log = LoggerFactory.getLogger(ZkUtils.class);

    CuratorFramework curatorFramework;
    LeaderLatch latch;
    String zkWorkspace;
    String hostname;
    InterProcessMutex mutex;
    ObjectMapper objectMapper;

    public ZkUtils(CuratorFramework curatorFramework, String zkWorkspace) throws UnknownHostException {
        this.curatorFramework = curatorFramework;
        this.zkWorkspace = zkWorkspace;
        this.objectMapper = new ObjectMapper();


        this.latch = new LeaderLatch(curatorFramework, zkWorkspace + "/latch", InetAddress.getLocalHost().getCanonicalHostName());

        this.mutex = new InterProcessMutex(curatorFramework, zkWorkspace + "/working");
        this.hostname = InetAddress.getLocalHost().getHostName();
    }

    public void initLeaderSelection(){

        try {
            latch.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public boolean hasLeader(){
        return checkIfExist(String.format("%s/latch", zkWorkspace));
    }

    public boolean isLeader() {
        return latch.hasLeadership();
    }


    public Map<String, Object> readJsonFromNode(String node){

        Map <String, Object> json = new HashMap<>();

        try {
            byte [] data = curatorFramework.getData().forPath(String.format("%s/%s", zkWorkspace, node));
            json = JsonUtils.read(data);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return json;
    }

    public Map<String, Object> readJsonFrom(String zkPath){

        Map <String, Object> json = new HashMap<>();

        try {
            byte [] data = curatorFramework.getData().forPath(zkPath);
            json = JsonUtils.read(data);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return json;
    }

    public void writeJsonInPath(String zkPath, Object obj){

        String completePath = zkPath;

        if(!zkPath.startsWith("/"))
            completePath = String.format("/%s", zkPath);

        try {
            this.curatorFramework.setData().forPath(completePath, JsonUtils.getWriter().writeValueAsBytes(obj));

            log.info("Writing data {} in path {}", obj, completePath);

        }catch (Exception e) {
            log.warn("I can't write data in path {}!", completePath);
            e.printStackTrace();
        }
    }

    public void writeJsonInNode(String node, Object obj){

        String completePath = String.format("%s/%s",zkWorkspace,node);

        try {
            this.curatorFramework.setData().forPath(completePath, JsonUtils.getWriter().writeValueAsBytes(obj));

            log.info("Writing data {} in node {}", obj, completePath);

        }catch (Exception e) {
            log.warn("I can't write data in path {}!", completePath);
            e.printStackTrace();
        }


    }

    public boolean checkIfExist(String zkPath) {

        boolean exist = false;

        try {
            exist = curatorFramework.checkExists().forPath(zkPath) != null;
        } catch (Exception e) {
            log.error("Can't register this node {}", hostname);
        }

        return exist;
    }

    public void registerNode() {
        try {
            String zkPath = zkWorkspace + "/workers/" + hostname;

            if (!checkIfExist(zkPath)) {
                curatorFramework.create().creatingParentsIfNeeded().forPath(zkPath, "0".getBytes());
            }

        } catch (Exception e) {
            log.error("Can't register this node {}", hostname);
        }
    }

    public void unRegisterNode() {
        try {
            String zkPath = zkWorkspace + "/workers/" + hostname;

            if (checkIfExist(zkPath)) {
                curatorFramework.delete().forPath(zkPath);
            }

        } catch (Exception e) {
            log.error("Can't unregister this node {}", hostname);
        }
    }


    public Integer incrementTask() {
        String zkPath = zkWorkspace + "/workers/" + hostname;
        Integer works = 0;
        try {
            byte[] data = curatorFramework.getData().forPath(zkPath);
            works = new Integer(new String(data));
            works++;
            curatorFramework.setData().forPath(zkPath, works.toString().getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }

        return works;
    }

    public void deleteDataInPath(String path){
        try {
            curatorFramework.delete().forPath(path);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void createNodeIfNotExistInPath(String node, String path){

        String completePath = String.format("%s/%s/%s", zkWorkspace, path, node);

        try {
            if(!checkIfExist(completePath)) {
                log.info("Created new node in : \"{}\"", curatorFramework.create().forPath(completePath));
            }else
                log.info("Path \"{}\" already exist!",completePath);
        } catch (Exception e) {
            e.printStackTrace();
        }


    }

    public void createEphemeralNodeIfNotExist(String node){

        String completePath = String.format("%s/%s",zkWorkspace,node);

        try{
            if(!checkIfExist(completePath)){
                log.info("Created new ephemeral node in : \"{}\"", curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(completePath));
            }else{
                log.info("Path \"{}\" already exist!",completePath);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void createNodeIfNotExist(String node){

        String completePath = String.format("%s/%s",zkWorkspace,node);

        try {
            if(!checkIfExist(completePath)) {
                log.info("Created new node in : \"{}\"", curatorFramework.create().forPath(completePath));
            }else
                log.info("Path \"{}\" already exist!",completePath);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public void setMutex() {
        try {
            log.info("Waiting on mutex. Other node is working ...");
            mutex.acquire();
            log.info("Setting mutex. Now, I'm working.");
        } catch (Exception e) {
            log.error("Can't setMutex");
        }
    }

    public void shutdown(){

        try {

            latch.close();
            releaseMutex();
            curatorFramework.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void releaseMutex() {
        try {
            mutex.release();
            log.info("Releasing mutex. Is time to relax.");
        } catch (Exception e) {
            log.error("Can't releaseMutex", hostname);
        }
    }

    public void watcherData(CuratorWatcher watcher, String zkPath){

        try{
            curatorFramework.getData().usingWatcher(watcher).forPath(zkPath);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void watcherChildren(CuratorWatcher watcher, String zkPath) {
        try {

            curatorFramework.getChildren().usingWatcher(watcher).forPath(zkPath);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public String discoverLeader(){

        String id = "Unknown";

        try {
            id = latch.getLeader().getId();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return id;

    }

}
