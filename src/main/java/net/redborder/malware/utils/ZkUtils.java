package net.redborder.malware.utils;

        import org.apache.curator.framework.CuratorFramework;
        import org.apache.curator.framework.api.CuratorWatcher;
        import org.apache.curator.framework.recipes.leader.LeaderLatch;
        import org.apache.curator.framework.recipes.locks.InterProcessMutex;
        import org.apache.zookeeper.CreateMode;
        import org.codehaus.jackson.map.ObjectMapper;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;

        import java.net.InetAddress;
        import java.util.HashMap;
        import java.util.Map;

public class ZkUtils {

    final Logger log = LoggerFactory.getLogger(ZkUtils.class);
    CuratorFramework curatorFramework;
    LeaderLatch latch;
    String zkWorkspace;
    String hostname;
    InterProcessMutex mutex;
    ObjectMapper objectMapper;

    public ZkUtils(CuratorFramework curatorFramework, String zkWorkspace) {
        this.curatorFramework = curatorFramework;
        this.zkWorkspace = zkWorkspace;
        this.objectMapper = new ObjectMapper();
        this.latch = new LeaderLatch(curatorFramework, zkWorkspace + "/latch");
        this.mutex = new InterProcessMutex(curatorFramework, zkWorkspace + "/working");

        try {
            this.hostname = InetAddress.getLocalHost().getHostName();
            latch.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public boolean leaderIsSelected(){

        boolean leaderSelected = false;

        try {
            leaderSelected = latch.getLeader() != null;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return  leaderSelected;

    }

    public String getCurrentLeaderName(){

        String leaderName = null;

        try {
            leaderName = latch.getLeader().getId();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return leaderName;
    }



    public boolean isLeader() {
        return latch.hasLeadership();
    }


    public Map<String, String> readJsonFromNode(String node){

        Map <String, String> json = new HashMap<>();

        try {
            byte [] data = curatorFramework.getData().forPath(String.format("%s/%s", zkWorkspace, node));
            json = JsonUtils.read(data);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return json;
    }

    public Map<String, String> readJsonFrom(String zkPath){

        Map <String, String> json = new HashMap<>();

        try {
            byte [] data = curatorFramework.getData().forPath(zkPath);
            json = JsonUtils.read(data);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return json;
    }

    public void writeJsonInPath(String zkPath, Object obj){

        String completePath;

        if(zkPath.startsWith("/"))
            completePath = String.format("%s%s", zkWorkspace, zkPath);
        else
            completePath = String.format("%s/%s",zkWorkspace, zkPath);

        try {
            this.curatorFramework.setData().forPath(completePath, JsonUtils.getWriter().writeValueAsBytes(obj));

            log.info("Writing data {} in path {}", obj, completePath);

        }catch (Exception e) {
            log.warn("I can't write data in path {}!", completePath);
            e.printStackTrace();
        }
    }

    public void writeJsonInNode(String node, Object obj){

        String completePath = String.format("%s/%s",zkWorkspace,node);

        try {
            this.curatorFramework.setData().forPath(completePath, JsonUtils.getWriter().writeValueAsBytes(obj));

            log.info("Writing data {} in node {}", obj, completePath);

        }catch (Exception e) {
            log.warn("I can't write data in path {}!", completePath);
            e.printStackTrace();
        }


    }

    public boolean checkIfExist(String zkPath) {

        boolean exist = false;

        try {
            exist = curatorFramework.checkExists().forPath(zkPath) != null;
        } catch (Exception e) {
            log.error("Can't register this node {}", hostname);
        }

        return exist;
    }

    public void registerNode() {
        try {
            String zkPath = zkWorkspace + "/workers/" + hostname;

            if (!checkIfExist(zkPath)) {
                curatorFramework.create().creatingParentsIfNeeded().forPath(zkPath, "0".getBytes());
            }

        } catch (Exception e) {
            log.error("Can't register this node {}", hostname);
        }
    }

    public void unRegisterNode() {
        try {
            String zkPath = zkWorkspace + "/workers/" + hostname;

            if (checkIfExist(zkPath)) {
                curatorFramework.delete().forPath(zkPath);
            }

        } catch (Exception e) {
            log.error("Can't unregister this node {}", hostname);
        }
    }


    public Integer incrementTask() {
        String zkPath = zkWorkspace + "/workers/" + hostname;
        Integer works = 0;
        try {
            byte[] data = curatorFramework.getData().forPath(zkPath);
            works = new Integer(new String(data));
            works++;
            curatorFramework.setData().forPath(zkPath, works.toString().getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }

        return works;
    }

    public void createNodeIfNotExistInPath(String node, String path){

        String completePath = String.format("%s/%s/%s", zkWorkspace, path, node);

        try {
            if(!checkIfExist(completePath)) {
                log.info("Created new node in : \"{}\"", curatorFramework.create().forPath(completePath));
            }else
                log.info("Path \"{}\" already exist!",completePath);
        } catch (Exception e) {
            e.printStackTrace();
        }


    }

    public void createEphemeralNodeIfNotExist(String node){

        String completePath = String.format("%s/%s",zkWorkspace,node);

        try{
            if(!checkIfExist(completePath)){
                log.info("Created new ephemeral node in : \"{}\"", curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(completePath));
            }else{
                log.info("Path \"{}\" already exist!",completePath);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void createNodeIfNotExist(String node){

        String completePath = String.format("%s/%s",zkWorkspace,node);

        try {
            if(!checkIfExist(completePath)) {
                log.info("Created new node in : \"{}\"", curatorFramework.create().forPath(completePath));
            }else
                log.info("Path \"{}\" already exist!",completePath);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public void setMutex() {
        try {
            log.info("Waiting on mutex. Other node is working ...");
            mutex.acquire();
            log.info("Setting mutex. Now, I'm working.");
        } catch (Exception e) {
            log.error("Can't setMutex");
        }
    }

    public void shutdown(){

        try {

            latch.close();
            releaseMutex();
            curatorFramework.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void releaseMutex() {
        try {
            mutex.release();
            log.info("Releasing mutex. Is time to relax.");
        } catch (Exception e) {
            log.error("Can't releaseMutex", hostname);
        }
    }

    public void watcherChildren(CuratorWatcher watcher, String zkPath) {
        try {
            curatorFramework.getChildren().usingWatcher(watcher).forPath(zkPath);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
