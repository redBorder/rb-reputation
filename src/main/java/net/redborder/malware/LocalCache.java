package net.redborder.malware;

import com.google.common.base.Optional;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.AeroSpikeManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

public class LocalCache {

    private static final Logger log = LoggerFactory.getLogger(LocalCache.class);

    private static AeroSpikeManager aeroSpikeManager;

    private static LoadingCache<String, Map<String, Object>> cache;

    private static Config config;

    public static void init(Config config) {

        long ttl = config.getTime("malware.cache.ttl", "2M");

        try {
            config = new Config(config.get("malware.controller.datamodules.configpath"));
        } catch (ConfigException e) {
            e.printStackTrace();
        }

        try {
            aeroSpikeManager = new AeroSpikeManager(config);
        } catch (ConfigException e) {
            e.printStackTrace();
        }

        cache = CacheBuilder.newBuilder()
                .expireAfterAccess(ttl, TimeUnit.MILLISECONDS)
                .maximumSize(Integer.MAX_VALUE)
                .weakKeys()
                .recordStats()
                .build(new CacheLoader<String, Map<String, Object>>() {

                    @Override
                    public Map<String, Object> load(String s) throws Exception {

                        Map<String, Object> result = aeroSpikeManager.get("malware", "rb_malware", s);

                        if (result != null)
                            return result;
                        else
                            return new HashMap<>();

                    }

                });
    }

    public static Map<String, Object> read(String key) {

        Map<String, Object> result = new HashMap<>();

        try {
            result = cache.get(key);
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        if (result.isEmpty())
            cache.invalidate(key);

        return result;
    }

    public static void reset() {
        cache.invalidateAll();
    }

    public static String getContent(){
        return cache.asMap().toString();
    }
}
