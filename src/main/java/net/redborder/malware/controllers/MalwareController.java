package net.redborder.malware.controllers;

import net.redborder.malware.MalwareREST;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spark.Request;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.*;

public class MalwareController {

    // Singleton pattern
    private static MalwareController INSTANCE;

    public enum Status {
        NOT_STARTED, SYNCHRONIZING, SYNCHRONIZED, READY, PROCESSING, STOPPED
    }

    // Logging
    private static final Logger log = LoggerFactory.getLogger(MalwareController.class);

    // Current status
    private volatile Status currentStatus;

    // Priority queue
    private PriorityBlockingQueue<Object> priorityBlockingQueue = null;

    // Configuration file
    private Config conf;

    private ZkUtils zkUtils = null;
    private CuratorFramework curatorClient = null;

    private int SYNC_TIME_INTERVAL = 500;

    public static void init(Config conf){
        if(INSTANCE == null)
            INSTANCE = new MalwareController(conf);
    }

    public MalwareController(Config conf) {

        this.priorityBlockingQueue = priorityBlockingQueue;

        currentStatus = Status.NOT_STARTED;

        this.conf = conf;

        try {
            init();

            // Init Curator client
            curatorClient = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            curatorClient.start();

            // Init zkUtils
            zkUtils = new ZkUtils(curatorClient, String.format("/%s", conf.get("malware.zkWorkspace")));
            // Register node
            zkUtils.registerNode();
            zkUtils.initLeaderSelection();

            // Create new
            MalwareREST.setController(this);

        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (ConfigException e) {
            e.printStackTrace();
        }

    }

    public static void start(){
        INSTANCE.ignit();
    }

    public final void ignit() {

        currentStatus = Status.SYNCHRONIZING;

        while (!zkUtils.checkIfExist("/malware_list/leader")) {

            log.info("Checking if leader is selected...");

            // Am I the leader?
            if (zkUtils.isLeader()) { // Yes

                // Create node "leader"
                zkUtils.createEphemeralNodeIfNotExist("leader");
                // Create node "revision"
                zkUtils.createEphemeralNodeIfNotExist("revision");

                Map<String, Object> json = new HashMap<>();
//                json.put("revision", String.valueOf(malwareRevisionList.getRevisionNumber()));
                zkUtils.writeJsonInNode("revision", json);

                json.clear();


                try {
                    json.put("leader",InetAddress.getLocalHost().getCanonicalHostName());
                    zkUtils.writeJsonInNode("leader", json);
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

            }

            try {
                Thread.sleep(SYNC_TIME_INTERVAL);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        if (!zkUtils.isLeader()) {

            // Get revision
            int revisionNum = Integer.valueOf(zkUtils.readJsonFrom("/malware_list/revision").get("revision"));
            log.info("Set revision to {}", revisionNum);

            // Put watcher on children node
            TaskWatcher taskWatcher = new TaskWatcher();
            zkUtils.watcherChildren(taskWatcher, "/malware_list/leader");
            log.info("Added watcher for node change to /malware_list/leader");

            zkUtils.watcherData(taskWatcher, "/malware_list/revision");
            log.info("Added watcher for data change to /malware_list/revision");
        }

        currentStatus = Status.READY;
    }

    private void init() throws ConfigException {
        SYNC_TIME_INTERVAL = conf.getInt("malware.sync.time.ms", 500);
    }

    public static void shutdownController(){
        INSTANCE.shutdown();
    }

    public void shutdown() {
        log.info("Shutting down...");
        zkUtils.shutdown();
        log.info("Shutdown!");
    }

    public static void processPetition(Request petition){
        INSTANCE.process(petition);
    }

    public void process(Request petition) {
        currentStatus = Status.PROCESSING;
        priorityBlockingQueue.add(petition);
        currentStatus = Status.READY;
    }

    private class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    break;

                case NodeDataChanged:
                    log.info("Data from node {} changed!", watchedEvent.getPath());
                    break;
            }

        }
    }

}
