package net.redborder.malware.controllers;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import net.redborder.malware.IncrementalList;
import net.redborder.malware.MalwareREST;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.modules.data.OTXDataModule;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.recipes.leader.LeaderLatchListener;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class MalwareController{

    public enum Status {
        NOT_STARTED, SYNCHRONIZING, SYNCHRONIZED, READY, PROCESSING, STOPPED
    }

    // Logging
    private static final Logger log = LoggerFactory.getLogger(MalwareController.class);

    // Host for leader
    private static String leaderHost;

    // OTX Data Module
    private static OTXDataModule otxDataModule;

    // Current status
    private static volatile Status currentStatus;

    // Configuration file
    private static Config config;

    private static ZkUtils zkUtils = null;
    private static CuratorFramework curatorClient = null;

    public static void init(Config conf) {
        log.info("Initializing malware controller ...");

        currentStatus = Status.NOT_STARTED;

        config = conf;

        try {

            // Init Curator client
            curatorClient = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            curatorClient.start();

            // Init zkUtils
            zkUtils = new ZkUtils(curatorClient, String.format("/%s", conf.get("malware.zkWorkspace")));

            // Register node
            zkUtils.registerNode();

            // First check if leader exists, if leader exists
            if(zkUtils.checkIfExist("/rb_reputation/leader")){

                // Wait 2 seconds
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // And we get the leader host, we will request incremental list
                leaderHost = zkUtils.readJsonFrom("leader").get("leader").toString();
                log.info("Current leader is {}", leaderHost);

                // Get current incremental
                Map<String, Object> json = zkUtils.readJsonFrom("incremental");

                log.trace("Incremental JSON info : {}", json);

                // Getting current parameters
                String currentIncremental = json.get("current").toString();
                String releasedIncremental = json.get("released").toString();
                int counter = (int)json.get("count");

                log.info("Current incremental in leader is {}", currentIncremental);

                String token[] = currentIncremental.split("\\.");

                log.trace("tokens {}", token.toString());

                // Setting current incremental list
                IncrementalList.setIncremental(new Integer(token[0]), new Integer(token[1]), counter);

                token = releasedIncremental.split("\\.");

                // Setting last released incremental list
                IncrementalList.setLastIncremental(new Integer(token[0]), new Integer(token[1]));

                log.info("Set incremental to {}", currentIncremental);

                try {
                    // Now we get incremental list from leader
                    log.info("Getting incremental list from leader ...");

                    // We open a new connection
                    URL objLookupInc = new URL(String.format(String.format("http://%s/reputation/v1/malware/incremental/%s", leaderHost, releasedIncremental)));
                    HttpURLConnection connInc = (HttpURLConnection) objLookupInc.openConnection();
                    connInc.setRequestMethod("GET");
                    connInc.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
                    connInc.setRequestProperty("Accept", "application/json");
                    connInc.setDoOutput(true);
                    connInc.setDoInput(true);

                    log.info("Getting incremental {}", currentIncremental);

                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connInc.getInputStream()));
                    int responseCodeInc = connInc.getResponseCode();

                    StringBuffer response = new StringBuffer();
                    String inputLine;

                    while((inputLine = bufferedReader.readLine()) != null){
                        response.append(inputLine);
                    }

                    bufferedReader.close();

                    connInc.disconnect();

                    // If response is good, update incremental list
                    if(responseCodeInc == 200){
                        ObjectMapper _mapper = new ObjectMapper();
                        ArrayList<Map<String, Object>> incrementalList = _mapper.readValue(response.toString(), new TypeReference<ArrayList<Map<String, Object>>>(){});
                        IncrementalList.setIncrementalList(incrementalList);
                        log.info("Incremental list completed");
                    }else{
                        log.info("Incremental list not exist!");
                    }

                } catch (MalformedURLException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }

                // The watcher will watch both paths in zookeeper for data changes
                zkUtils.watcherData(new IncrementalWatcher(), "/rb_reputation/leader");
                log.info("Added watcher for data change to /rb_reputation/leader");

                zkUtils.watcherData(new IncrementalWatcher(), "/rb_reputation/incremental");
                log.info("Added watcher for data change to /rb_reputation/incremental");

            }

            // We will listen if we are the leader or not
            zkUtils.addLeaderListener(new MalwareLeaderListener());
            zkUtils.initLeaderSelection();

            log.info("Malware controller done!");

        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (ConfigException e) {
            e.printStackTrace();
        }

    }

    // Write a map object in node "incremental"
    public static void writeIncremental(Map<String, Object> map){
            zkUtils.writeJsonInNode("incremental", map);
    }

    // Read from node "incremental". Return map object
    public static Map<String, Object> readIncremental(){
        return zkUtils.readJsonFrom("incremental");
    }

    // Shutdown malware controller
    public static void shutdown() {
        log.info("Shutting down...");
        zkUtils.shutdown();

        if(otxDataModule != null)
            otxDataModule.shutdownImpl();

        IncrementalList.shutdown();

        log.info("Shutdown!");
    }

    // Return if this node is current leader
    public static boolean isCurrentLeader(){
        return zkUtils.isLeader();
    }

    private static class IncrementalWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.trace(String.format("%d[INCREMENTAL WATCH] NotifyWatcher: %s", Thread.currentThread().getId(), type.name()));

            switch (type) {
                case NodeDataChanged:

                    if(!zkUtils.isLeader()){
                        log.info("Checking incremental list ...");
                        IncrementalList.check();

                        IncrementalWatcher taskWatcher = new IncrementalWatcher();
                        zkUtils.watcherData(taskWatcher, "/rb_reputation/incremental");
                        log.info("Added watcher for data change to /rb_reputation/incremental");


                    }
                    break;
            }

        }


    }

    private static class LeaderWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.trace(String.format("%d[LEADER WATCH] NotifyWatcher: %s", Thread.currentThread().getId(), type.name()));

            switch (type) {
                case NodeDataChanged:

                    if(!zkUtils.isLeader()){

                        leaderHost = zkUtils.readJsonFrom("leader").get("leader").toString();
                        log.info("Current leader is {}", leaderHost);

                        LeaderWatcher taskWatcher = new LeaderWatcher();
                        zkUtils.watcherData(taskWatcher, "/rb_reputation/leader");
                        log.info("Added watcher for data change to /rb_reputation/leader");
                    }
                    break;

                case NodeDeleted:
                    break;
            }

        }


    }

    private static class MalwareLeaderListener implements LeaderLatchListener{

        @Override
        public void isLeader() {
            log.info("I'm leader now!");

            Map<String, Object> json = new HashMap<>();

            zkUtils.setMutex();

            // Create ephemeral node "leader" if not exist
            zkUtils.createEphemeralNodeIfNotExist("leader");
            zkUtils.createEphemeralNodeIfNotExist("incremental");

            try {
                String leader = String.format("%s:%d",InetAddress.getLocalHost().getCanonicalHostName(), MalwareREST.RESTPort());
                json.put("leader", leader);
                zkUtils.writeJsonInNode("leader", json);

                otxDataModule = new OTXDataModule(config);
                otxDataModule.init();

                IncrementalList.start();

            } catch (UnknownHostException e) {
                e.printStackTrace();
            }

            zkUtils.releaseMutex();

        }

        @Override
        public void notLeader() {
            log.info("I'm not the leader anymore... =(");

            otxDataModule.shutdownImpl();
            IncrementalList.stop();
        }
    }

}
