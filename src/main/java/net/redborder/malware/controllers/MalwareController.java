package net.redborder.malware.controllers;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import net.redborder.malware.MalwareREST;
import net.redborder.malware.MalwareRevisionList;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.AeroSpikeManager;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spark.Request;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;

public class MalwareController {

    public enum Status {
        NOT_STARTED, SYNCHRONIZING, SYNCHRONIZED, READY, PROCESSING, STOPPED
    }

    private static final Logger log = LoggerFactory.getLogger(MalwareController.class);

    private volatile Status currentStatus;

    // Priority queue
    private PriorityBlockingQueue<Object> priorityBlockingQueue = new PriorityBlockingQueue<>();
    // Kafka2Queue
    private LinkedBlockingQueue<Map<String, Object>> queue;
    // Result queue
    private LinkedBlockingQueue<Object> resultBlockingQueue;

    private MalwareRevisionList malwareRevisionList;
    private Config conf;
    private Timer timerTask;
    private AeroSpikeManager aerospikeManager;
    private ZkUtils zkUtils = null;
    private CuratorFramework curatorClient;

    private int MS = 10000;
    private int OFFSET = 2;
    private int SYNC_TIME_INTERVAL = 500;

    private final String NAMESPACE = "malware";
    private final String COLLECTION = "rb_malware";

    public MalwareController(Config conf, PriorityBlockingQueue<Object> priorityBlockingQueue, LinkedBlockingQueue<Object> resultBlockingQueue) {

        currentStatus = Status.NOT_STARTED;

        this.conf = conf;

        this.priorityBlockingQueue = priorityBlockingQueue;
        this.resultBlockingQueue = resultBlockingQueue;

        try {
            init();

            // Init Curator client
            curatorClient = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            curatorClient.start();

            // Init zkUtils
            zkUtils = new ZkUtils(curatorClient, String.format("/%s", conf.get("malware.zkWorkspace")));
            // Register node
            zkUtils.registerNode();
            zkUtils.initLeaderSelection();

            // Create new
            malwareRevisionList = new MalwareRevisionList(OFFSET, this.queue);
            MalwareREST.setController(this);

        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (ConfigException e) {
            e.printStackTrace();
        }

    }

    public final void start() {

        currentStatus = Status.SYNCHRONIZING;

        while (!zkUtils.checkIfExist("/malware_list/leader")) {

            log.info("Checking if leader is selected...");

            // Am I the leader?
            if (zkUtils.isLeader()) { // Yes

                // Create node "leader"
                zkUtils.createEphemeralNodeIfNotExist("leader");
                // Create node "revision"
                zkUtils.createEphemeralNodeIfNotExist("revision");

                Map<String, Object> json = new HashMap<>();
                json.put("revision", String.valueOf(malwareRevisionList.getRevisionNumber()));
                zkUtils.writeJsonInNode("revision", json);

                json.clear();


                try {
                    json.put("leader",InetAddress.getLocalHost().getCanonicalHostName());
                    zkUtils.writeJsonInNode("leader", json);
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

            }

            try {
                Thread.sleep(SYNC_TIME_INTERVAL);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            malwareRevisionList.startContinuousQuery();
            initContinuousQuery();

        }

        if (!zkUtils.isLeader()) {

            // Get revision
            int revisionNum = Integer.valueOf(zkUtils.readJsonFrom("/malware_list/revision").get("revision"));
            log.info("Set revision to {}", revisionNum);

            Client client = Client.create();

            ObjectMapper mapper = new ObjectMapper();

            String list = client.resource(String.format("http://%s:%d/malware/revision/%d", zkUtils.readJsonFrom("/malware_list/leader").get("leader"), MalwareREST.getCurrentPort(), revisionNum)).accept("application/json").get(ClientResponse.class).getEntity(String.class);

            ArrayList<Map<String, Object>> currentRevision = null;

            try {
                currentRevision = mapper.readValue(list, new TypeReference<ArrayList<Map<String, Object>>>() {
                });
            } catch (IOException e) {
                e.printStackTrace();
            }

            malwareRevisionList.createAndRegisterNewRevision(currentRevision, revisionNum);
            malwareRevisionList.startContinuousQuery();

            // Put watcher on children node
            TaskWatcher taskWatcher = new TaskWatcher();
            zkUtils.watcherChildren(taskWatcher, "/malware_list/leader");
            log.info("Added watcher for node change to /malware_list/leader");

            zkUtils.watcherData(taskWatcher, "/malware_list/revision");
            log.info("Added watcher for data change to /malware_list/revision");
        }

        currentStatus = Status.READY;
    }

    private void init() throws ConfigException {
        MS = conf.getInt("malware.query.ms", 10000);
        OFFSET = conf.getInt("malware.revision.offset", 2);
        SYNC_TIME_INTERVAL = conf.getInt("malware.sync.time.ms", 500);
    }

    public void shutdown() {
        log.info("Shutting down...");
        zkUtils.shutdown();
        log.info("Shutdown!");
    }

    public void processPetition(Request petition) {
        currentStatus = Status.PROCESSING;
        priorityBlockingQueue.add(petition);
        currentStatus = Status.READY;
    }

    public ArrayList<Map<String, Object>> generateTotal() {
        return malwareRevisionList.getTotal();
    }

    public ArrayList<Map<String, Object>> generateCurrentRevision() {
        return malwareRevisionList.getCurrentRevision();
    }

    public ArrayList<Map<String, Object>> generateRevision(int revisionNum) {
        return malwareRevisionList.getRevNum(revisionNum);
    }

    public int getRevisionNumber() {
        return malwareRevisionList.getRevisionNumber();
    }

    public Map<String, Object> getDataForSHA(String sha) {
        return aerospikeManager.get(NAMESPACE, COLLECTION, sha);
    }

    private void initContinuousQuery() { // If the node isn't leader!!
        timerTask = new Timer();
        timerTask.schedule(new GenerateRevisionTask(), 0, MS);
    }

    private class GenerateRevisionTask extends TimerTask {
        @Override
        public void run() {
            ArrayList<Map<String, Object>> total = aerospikeManager.getList("malware", "rb_malware");

            for (Map<String, Object> m : total) {
                m.remove("cuckoo_before");
                m.put("action", "create");
            }

            malwareRevisionList.createTotal(total);
            malwareRevisionList.finishCurrentRevision();
        }
    }

    private class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    malwareRevisionList.stopContinuousQuery();
                    break;

                case NodeDataChanged:
                    malwareRevisionList.finishCurrentRevision();

                    log.info("Data from node {} changed!", watchedEvent.getPath());

                    ArrayList<Map<String, Object>> total = aerospikeManager.getList("malware", "rb_malware");

                    for (Map<String, Object> m : total) {
                        m.remove("cuckoo_before");
                        m.put("action", "create");
                    }

                    malwareRevisionList.createTotal(total);
                    break;
            }

        }
    }

}
