package net.redborder.malware.controllers;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.jaxrs.json.JsonMapperConfigurator;
import net.redborder.malware.IncrementalList;
import net.redborder.malware.MalwareREST;
import net.redborder.malware.MalwareService;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

public class MalwareController {

    public enum Status {
        NOT_STARTED, SYNCHRONIZING, SYNCHRONIZED, READY, PROCESSING, STOPPED
    }

    // Logging
    private static final Logger log = LoggerFactory.getLogger(MalwareController.class);

    // Current status
    private static volatile Status currentStatus;

    // Configuration file
    private static Config config;

    private static ZkUtils zkUtils = null;
    private static CuratorFramework curatorClient = null;

    private static int SYNC_TIME_INTERVAL = 1000;

    public static void init(Config conf) {

        currentStatus = Status.NOT_STARTED;

        config = conf;

        try {

            SYNC_TIME_INTERVAL = config.getInt("malware.sync.time.ms", 1500);

            // Init Curator client
            curatorClient = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            curatorClient.start();

            // Init zkUtils
            zkUtils = new ZkUtils(curatorClient, String.format("/%s", conf.get("malware.zkWorkspace")));

            // Register node
            zkUtils.registerNode();
            zkUtils.initLeaderSelection();

        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (ConfigException e) {
            e.printStackTrace();
        }

    }

    public static final void start() {
        currentStatus = Status.SYNCHRONIZING;

        while (!zkUtils.checkIfExist("/rb_reputation/leader")) {

            log.info("Checking if leader is selected...");

            // Am I the leader?
            if (zkUtils.isLeader()) { // Yes

                log.info("I'm leader!");
                // Create node "leader"
                zkUtils.createEphemeralNodeIfNotExist("leader");
                // Create node "revision"
                zkUtils.createEphemeralNodeIfNotExist("incremental");

                Map<String, Object> json = new HashMap<>();
//                zkUtils.writeJsonInNode("incremental", json);
//                json.clear();


                try {
                    String leader = String.format("%s:%d",InetAddress.getLocalHost().getCanonicalHostName(), MalwareREST.RESTPort());
                    json.put("leader", leader);
                    zkUtils.writeJsonInNode("leader", json);
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

            }

            try {
                TimeUnit.MILLISECONDS.sleep(SYNC_TIME_INTERVAL);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
        // I'm not leader
        if (!zkUtils.isLeader()) {

            // Get revision
            Map<String ,Object> json = zkUtils.readJsonFrom("/rb_reputation/incremental");
            String currentIncremental = json.get("current").toString();
            String releasedIncremental = json.get("released").toString();
            int counter = (int)json.get("count");

            log.info("Current incremental in leader {}", currentIncremental);

            String token[] = currentIncremental.split("\\.");

            log.info("tokens {}", token.toString());

            IncrementalList.setIncremental(new Integer(token[0]), new Integer(token[1]), counter);

            token = releasedIncremental.split("\\.");

            IncrementalList.setLastIncremental(new Integer(token[0]), new Integer(token[1]));

            log.info("Set incremental to {}", currentIncremental);

            String leaderHost = zkUtils.readJsonFrom("/rb_reputation/leader").get("leader").toString();

            log.info("Current leader is {}", leaderHost);

            try {
                log.info("Getting incremental list from leader ...");
                URL objLookupInc = new URL(String.format(String.format("http://%s/api/v1.0/malware/incremental/%s", leaderHost, releasedIncremental)));
                HttpURLConnection connInc = (HttpURLConnection) objLookupInc.openConnection();
                connInc.setRequestMethod("GET");
                connInc.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
                connInc.setRequestProperty("Accept", "application/json");
                connInc.setDoOutput(true);
                connInc.setDoInput(true);

                log.info("Getting incremental {}", currentIncremental);

                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connInc.getInputStream()));
                int responseCodeInc = connInc.getResponseCode();

                StringBuffer response = new StringBuffer();
                String inputLine;

                while((inputLine = bufferedReader.readLine()) != null){
                    response.append(inputLine);
                }

                bufferedReader.close();

                connInc.disconnect();

                if(responseCodeInc == 200){
                    ObjectMapper _mapper = new ObjectMapper();
                    ArrayList<Map<String, Object>> incrementalList = _mapper.readValue(response.toString(), new TypeReference<ArrayList<Map<String, Object>>>(){});
                    IncrementalList.setIncrementalList(incrementalList);
                    log.info("Incremental list completed");
                }

            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Put watcher on children node
            TaskWatcher taskWatcher = new TaskWatcher();
            zkUtils.watcherChildren(taskWatcher, "/rb_reputation/leader");
            log.info("Added watcher for node change to /rb_reputation/leader");

            zkUtils.watcherData(taskWatcher, "/rb_reputation/incremental");
            log.info("Added watcher for data change to /rb_reputation/incremental");
        }

        currentStatus = Status.READY;
    }

    public static void writeInRevision(Map<String, Object> map){
            zkUtils.writeJsonInNode("incremental", map);
    }

    public static void shutdown() {
        log.info("Shutting down...");
        zkUtils.shutdown();
        log.info("Shutdown!");
    }
    public static boolean isLeader(){
        return zkUtils.isLeader();
    }

    private static class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    TimeUnit.SECONDS.sleep(3);
                    MalwareController.start();
                    TimeUnit.SECONDS.sleep(SYNC_TIME_INTERVAL);
                    break;

                case NodeDataChanged:
                    log.info("Checking incremental list ...");
                    IncrementalList.check();

                    TaskWatcher taskWatcher = new TaskWatcher();
                    zkUtils.watcherData(taskWatcher, "/rb_reputation/incremental");
                    log.info("Added watcher for data change to /rb_reputation/incremental");

                    break;
            }

        }


    }

}
