package net.redborder.malware.controllers;

import net.redborder.malware.IncrementalList;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.util.*;

public class MalwareController {

    public enum Status {
        NOT_STARTED, SYNCHRONIZING, SYNCHRONIZED, READY, PROCESSING, STOPPED
    }

    // Logging
    private static final Logger log = LoggerFactory.getLogger(MalwareController.class);

    // Current status
    private static volatile Status currentStatus;

    // Configuration file
    private static Config config;

    private static ZkUtils zkUtils = null;
    private static CuratorFramework curatorClient = null;

    private static int SYNC_TIME_INTERVAL = 500;

    public static void init(Config conf) {

        currentStatus = Status.NOT_STARTED;

        config = conf;

        try {

            SYNC_TIME_INTERVAL = config.getInt("malware.sync.time.ms", 500);

            // Init Curator client
            curatorClient = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            curatorClient.start();

            // Init zkUtils
            zkUtils = new ZkUtils(curatorClient, String.format("/%s", conf.get("malware.zkWorkspace")));

            // Register node
            zkUtils.registerNode();
            zkUtils.initLeaderSelection();

        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (ConfigException e) {
            e.printStackTrace();
        }
    }

    public static final void start() {
        currentStatus = Status.SYNCHRONIZING;

        while (!zkUtils.checkIfExist("/malware_list/leader")) {

            log.info("Checking if leader is selected...");

            // Am I the leader?
            if (zkUtils.isLeader()) { // Yes

                // Create node "leader"
                zkUtils.createEphemeralNodeIfNotExist("leader");
                // Create node "revision"
                zkUtils.createEphemeralNodeIfNotExist("revision");

                Map<String, Object> json = new HashMap<>();
                zkUtils.writeJsonInNode("revision", json);

                json.clear();


                try {
                    json.put("leader", InetAddress.getLocalHost().getCanonicalHostName());
                    zkUtils.writeJsonInNode("leader", json);
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

            }

            try {
                Thread.sleep(SYNC_TIME_INTERVAL);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        if (!zkUtils.isLeader()) {

            // Get revision
            String incremental = zkUtils.readJsonFrom("/malware_list/revision").get("revision");
            String token[] = incremental.split(".");

            IncrementalList.setIncremental(new Integer(token[0]), new Integer(token[1]));

            log.info("Set incremental to {}", incremental);

            String leaderHost = zkUtils.readJsonFrom("malware_list/leader").get("leader");

            try {

                URL objLookup = new URL(String.format(String.format("http://%s:7777", leaderHost)));
                HttpURLConnection conn = (HttpURLConnection) objLookup.openConnection();
                conn.setRequestMethod("GET");
                conn.setRequestProperty("last", "incremental");

                int responseCode = conn.getResponseCode();

                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                StringBuffer response = new StringBuffer();
                String inputLine;

                while((inputLine = bufferedReader.readLine()) != null){
                    response.append(inputLine);
                }

                bufferedReader.close();

                switch(responseCode){
                    case 200:
                        log.info("CODE 200 Petition completed");
                        break;
                }

            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Put watcher on children node
            TaskWatcher taskWatcher = new TaskWatcher();
            zkUtils.watcherChildren(taskWatcher, "/malware_list/leader");
            log.info("Added watcher for node change to /malware_list/leader");

            zkUtils.watcherData(taskWatcher, "/malware_list/revision");
            log.info("Added watcher for data change to /malware_list/revision");
        }

        currentStatus = Status.READY;
    }

    public static void writeInRevision(Map<String, Object> map){
        zkUtils.writeJsonInNode("revision", map);
    }

    public static void shutdown() {
        log.info("Shutting down...");
        zkUtils.shutdown();
        log.info("Shutdown!");
    }

    private static class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    break;

                case NodeDataChanged:
                    log.info("Data from node {} changed!", watchedEvent.getPath());
                    break;
            }

        }


    }

}
