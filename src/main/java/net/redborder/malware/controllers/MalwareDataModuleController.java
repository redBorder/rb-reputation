package net.redborder.malware.controllers;

import net.redborder.malware.IncrementalList;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MalwareDataModuleController {

    public enum Process {
        FULL
    }

    private static final Logger log = LoggerFactory.getLogger(MalwareDataModuleController.class);

    // Map of data module loaded
    private Map<String, DataModule> loadedModules = new HashMap<>();

    // List of loaded modules order by priority
    private SortedMap<String, LinkedList<DataModule>> priorityModules = new TreeMap<>();

    // Config file
    private Config conf;

    private Process processing;

    private MalwareOutputModuleController outputModuleController;

    public MalwareDataModuleController(Config conf) {

        this.conf = conf;
        outputModuleController = new MalwareOutputModuleController(this.conf);
    }

    public void init() {

        outputModuleController.init();

        log.info("Init Data Module Controller");

        // Empty list
        List<String> modules = new ArrayList<>();

        try {
            // Getting modules from config file
            modules = conf.getList("malware.controller.datamodules");
        } catch (ConfigException e) {
            e.printStackTrace();
        }

        Pattern pattern = Pattern.compile("(?<class>.+(?:\\.(?<module>[a-zA-Z]+DataModule)))(?:\\:(?<pref>\\d{1,}))?");

        log.info("Loading data modules ...");

        // for each module
        for (String module : modules) {
            // Matcher for regex comparation
            Matcher match;

            if ((match = pattern.matcher(module)).matches()) {
                try {
                    // Reflexive construction
                    Constructor constructor = Class.forName(match.group("class")).getConstructor(Config.class);

                    DataModule loadedDataModule = (DataModule) constructor.newInstance(conf);

                    loadedDataModule.init();

                    log.info("Init {} data module", loadedDataModule.getDataModuleName());

                    String priority = match.group("pref");

                    // If not exist a list of priority modules
                    if (priority != null && !priorityModules.containsKey(priority))
                        priorityModules.put(priority, new LinkedList<DataModule>());

                    // If exist
                    if (!loadedDataModule.getDataModuleName().matches("(?:AeroSpike|LocalCache)"))
                        priorityModules.get(priority).push(loadedDataModule);

                    loadedModules.put(loadedDataModule.getDataModuleName(), loadedDataModule);

                    log.info(String.format("Loaded %s module with prioriry %s.", loadedDataModule.getDataModuleName(), priority));

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }

        }// for

        log.info("Loaded {} modules", loadedModules.size());
        log.info("Priority modules: {}", priorityModules.toString());

        IncrementalList.linkDataModules(loadedModules);
    }

    public int numberOfLoadedModules() {
        return loadedModules.size();
    }

    public Object getFullData() {

        log.info("Processing full data ...");

        // result
        LinkedList<Object> fullDataList = new LinkedList<>();

        CountDownLatch latch = new CountDownLatch(loadedModules.size());

        ExecutorService executorService = Executors.newFixedThreadPool(loadedModules.size());

        for (DataModule dataModule : loadedModules.values()) {
            dataModule.addLatch(latch);
            dataModule.selectOperation(DataModule.Operation.FULL);
            executorService.submit(dataModule);
        }

        // Waiting all the results
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        log.info("Getting results ...");

        // Getting results
        for (DataModule module : loadedModules.values())
            fullDataList.push(module.getOperationResult());

        // Return results
        return fullDataList;
    }

    public void setProcessing(String value) {
        log.info("Set processing to {}", value);
        processing = Process.valueOf(value.toUpperCase());
    }

    public Object doQuery(Object query) {

        Map<String, Object> results = new HashMap<>();
        results.put("sha256", query.toString());

        log.info("Processing query ...");

        if (loadedModules.containsKey("LocalCache")) {
            CountDownLatch latch = new CountDownLatch(1);
            DataModule localCache = loadedModules.get("LocalCache");
            localCache.addLatch(latch);
            localCache.prepareQuery(query);
            Map<String, Object> cacheResult = (HashMap<String, Object>) localCache.doQuery();

            if (!cacheResult.isEmpty()) {
                log.info("Query completed in LocalCache data module!");
                return cacheResult;
            }

        }

        if (processing.compareTo(Process.FULL) == 0) {
            log.info("Processing with priority modules ... ");

            // List of priority modules
            for (LinkedList<DataModule> listPreferentedModules : priorityModules.values()) {

                CountDownLatch latch = new CountDownLatch(listPreferentedModules.size());

                log.info("Created new latch for {} modules", listPreferentedModules.size());

                ExecutorService executorService = Executors.newFixedThreadPool(listPreferentedModules.size());

                for (DataModule dataModule : listPreferentedModules) {
                    log.info("Doing query for module {}", dataModule.getDataModuleName());

                    dataModule.addLatch(latch);
                    dataModule.prepareQuery(query);
                    dataModule.selectOperation(DataModule.Operation.QUERY);
                    executorService.submit(dataModule);
                }

                log.info("Waiting for results ...");

                try {
                    latch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                log.info("Checking results ...");

                for (DataModule dataModule : listPreferentedModules) {
                    Map<String, Object> result;
                    if ((result = (HashMap)dataModule.getOperationResult()) != null) {

                        log.info("Found new result for {} ", dataModule.getDataModuleName());

                        results.put(dataModule.getDataModuleName(), result.get("score"));
                    }else{
                        log.info("Result not found for {}; Setting default value", dataModule.getDataModuleName());
                        results.put(dataModule.getDataModuleName(), 0);
                    }
                }

            }

        }

        outputModuleController.writeInOutput("AeroSpike", results);

        return results;
    }

}
