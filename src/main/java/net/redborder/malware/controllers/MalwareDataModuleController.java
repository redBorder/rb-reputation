package net.redborder.malware.controllers;

import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MalwareDataModuleController {

    private static final Logger log = LoggerFactory.getLogger(MalwareDataModuleController.class);

    // Map of data module loaded
    private Map<String, DataModule> loadedModules = new HashMap<>();

    // List of loaded modules order by priority
    private SortedMap<Integer, LinkedList<DataModule>> priorityModules = new TreeMap<>();

    private Map<String, Object> incremental = new HashMap<>();
    private int currentRevision = 1;
    private int currentIncremental = 0;
    // Config file
    private Config conf;

    private Timer generateIncremental;
    private Timer generateRevision;
    private MalwareOutputModuleController outputModuleController;

    public MalwareDataModuleController(Config conf) {

        this.conf = conf;
        outputModuleController = new MalwareOutputModuleController(this.conf);
    }

    public void init() {

        log.info("Init Data Module Controller");

        generateIncremental = new Timer();
        generateRevision = new Timer();

        // Empty list
        List<String> modules = new ArrayList<>();

        try {
            // Getting modules from config file
            modules = conf.getList("malware.controller.datamodules");
        } catch (ConfigException e) {
            e.printStackTrace();
        }

        Pattern pattern = Pattern.compile("(?<class>.+(?<module>[a-zA-Z]+)):(?<pref>\\d{1,})");

        log.info("Loading data modules");

        // for each module
        for (String module : modules) {
            // Matcher for regex comparation
            Matcher match;

            if ((match = pattern.matcher(module)).matches())

                try {
                    // Reflexive construction
                    Constructor constructor = Class.forName(match.group("class")).getConstructor(Config.class);

                    DataModule loadedDataModule = (DataModule)constructor.newInstance(conf);

                    loadedDataModule.init();

                    int priority = Integer.valueOf(match.group("pref"));

                    // If not exist a list of priority modules
                    if(!priorityModules.containsKey(priority))
                        priorityModules.put(priority, new LinkedList<DataModule>());

                    // If exist
                    priorityModules.get(priority).push(loadedDataModule);

                    loadedModules.put(loadedDataModule.getDataModuleName(), loadedDataModule);

                    log.info(String.format("Loaded {} module.", loadedDataModule.getDataModuleName()));

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }



        }// for

        generateRevision.scheduleAtFixedRate(new GenerateRevision(), 0L, TimeUnit.DAYS.toMillis(1));
        generateIncremental.scheduleAtFixedRate(new GenerateIncremental(), 0L, TimeUnit.MINUTES.toMillis(15));

    }

    public int numberOfLoadedModules(){
        return loadedModules.size();
    }


    public Object getFullData(){

        log.info("Processing full data...");

        // result
        LinkedList<Object> fullDataList = new LinkedList<>();

        CountDownLatch latch = new CountDownLatch(loadedModules.size());

        ExecutorService executorService = Executors.newFixedThreadPool(loadedModules.size());

        for(DataModule dataModule : loadedModules.values()){
            dataModule.addLatch(latch);
            dataModule.selectOperation(DataModule.Operation.FULL);
            executorService.submit(dataModule);
        }

        // Waiting all the results
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        log.info("Getting results...");

        // Getting results
        for(DataModule module : loadedModules.values())
            fullDataList.push(module.getOperationResult());

        // Return results
        return fullDataList;
    }

    public Object getIncremental(String incremental){
        return this.incremental.get(incremental);
    }

    public Object doQuery(Object query){

        Object result = new Object();

        DataModule localCache = loadedModules.get("LocalCahce");
        localCache.prepareQuery(query);
        result = localCache.doQuery();

        if(result != null)
            return result;

        DataModule aeroSpike = loadedModules.get("AeroSpike");
        aeroSpike.prepareQuery(query);
        result = aeroSpike.doQuery();

        if(result != null)
            return result;

        // List of priority modules
        for(LinkedList<DataModule> listPreferentedModules : priorityModules.values()){

            CountDownLatch latch = new CountDownLatch(listPreferentedModules.size());
            ExecutorService executorService = Executors.newFixedThreadPool(listPreferentedModules.size());

            for(DataModule dataModule : listPreferentedModules){

                dataModule.addLatch(latch);
                dataModule.prepareQuery(query);
                dataModule.selectOperation(DataModule.Operation.QUERY);

                executorService.submit(dataModule);

            }

            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if(result != null){
                break;
            }

        }

        outputModuleController.writeInOutput("AeroSpike", result);

        return result;
    }

    private class GenerateIncremental extends TimerTask {

        @Override
        public void run() {

            // Create the index
            String index = String.format("%d.%d",currentRevision, currentIncremental);

            ExecutorService executorService = Executors.newFixedThreadPool(loadedModules.size());
            CountDownLatch latch = new CountDownLatch(loadedModules.size());

            for(DataModule dataModule : loadedModules.values()) {
                dataModule.selectOperation(DataModule.Operation.INCREMENTAL);
                dataModule.addLatch(latch);

                executorService.submit(dataModule);
            }

            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            LinkedList<Object> list = new LinkedList<>();

            for(DataModule dataModule : loadedModules.values())
                list.push(dataModule.getOperationResult());

            incremental.put(index, list);
        }

    }

    private class GenerateRevision extends TimerTask{

        @Override
        public void run() {
            currentRevision++;
            currentIncremental = 0;
            incremental.clear();
        }

    }
}
