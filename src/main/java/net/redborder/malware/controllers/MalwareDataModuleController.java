package net.redborder.malware.controllers;

import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MalwareDataModuleController {

    private static final Logger log = LoggerFactory.getLogger(MalwareDataModuleController.class);

    // Map of data module loaded
    private Map<String, DataModule> loadedModules = new HashMap<>();

    // List of preference for loaded modules
    private SortedMap<Integer, LinkedList<DataModule>> preferenceModules = new TreeMap<>();

    private Config conf;

    public MalwareDataModuleController(Config conf) {

        this.conf = conf;
    }

    public void init() {

        log.info("Init Data Module Controller");

        List<String> modules = null;

        try {
            // Getting modules from config file
            modules = conf.getList("malware.controller.datamodules");
        } catch (ConfigException e) {
            e.printStackTrace();
        }

        // Getting Package
        String packageName = this.getClass().getPackage().getName();

        Pattern pattern = Pattern.compile(String.format("(?<class>%s\\.(?<module>[a-zA-Z]+)):(?<pref>\\d{1,3})", packageName.replaceAll("\\.", Matcher.quoteReplacement("\\."))));

        for (String module : modules) {

            Matcher match;

            if ((match = pattern.matcher(module)).matches())

                try {

                    Constructor constructor = Class.forName(match.group("class")).getConstructor(Config.class);

                    DataModule loadedDataModule = (DataModule)constructor.newInstance(conf);

                    loadedDataModule.init();

                    int preference = Integer.valueOf(match.group("pref"));

                    if(!preferenceModules.containsKey(preference))
                        preferenceModules.put(preference, new LinkedList<DataModule>());

                    preferenceModules.get(preference).push(loadedDataModule);
                    loadedModules.put(loadedDataModule.getDataModuleName(), loadedDataModule);

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }

        }

    }

    public int numberOfLoadedModules(){
        return loadedModules.size();
    }


    public Object getFullData(){

        LinkedList<Object> fullDataList = new LinkedList<>();

        CountDownLatch latch = new CountDownLatch(loadedModules.size());

        ExecutorService executorService = Executors.newFixedThreadPool(loadedModules.size());

        for(LinkedList<DataModule> listModules: preferenceModules.values()) {
            Iterator<DataModule> it = listModules.iterator();

            while(it.hasNext()){

                DataModule module = it.next();

                module.selectOperation(DataModule.Operation.FULL);
                executorService.submit(module);

            }

        }

        for(DataModule module : loadedModules.values())
            fullDataList.push(module.getOperationResult());

        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return fullDataList;
    }

    public Object getIncremental(){

        LinkedList<Object> incrementalList = new LinkedList<>();

        return incrementalList;
    }

    public Object doQuery(String module){

        DataModule dataModule = loadedModules.get(module);
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        dataModule.selectOperation(DataModule.Operation.QUERY);
        dataModule.prepareQuery(null);

        executorService.submit(dataModule);

        return dataModule.getOperationResult();
    }

}
