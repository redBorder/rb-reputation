package net.redborder.malware.controllers;

import net.redborder.malware.IncrementalList;
import net.redborder.malware.MalwareREST;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MalwareDataModuleController {

    private static final Logger log = LoggerFactory.getLogger(MalwareDataModuleController.class);

    // Map of data module loaded
    private Map<String, DataModule> loadedModules = new HashMap<>();

    // List of loaded modules order by priority
    private SortedMap<String, LinkedList<DataModule>> priorityModules = new TreeMap<>();

    // Config file
    private Config conf;

    // Selected process in query
    private MalwareREST.PROCESS process;

    // Selected response in query
    private MalwareREST.RESPONSE response;

    private MalwareOutputModuleController outputModuleController;

    // main constructor
    public MalwareDataModuleController(Config conf) {
        this.conf = conf;
        outputModuleController = new MalwareOutputModuleController(this.conf);
    }

    // Set response value
    public void setResponse(MalwareREST.RESPONSE response) {
        this.response = response;
    }

    // Init malware data module controller
    public void init() {

        outputModuleController.init();
        log.info("Initializing Data Module Controller");

        // Empty list of modules
        List<String> modules = new ArrayList<>();

        try {
            // Getting modules from config file
            modules = conf.getList("malware.controller.datamodules");
        } catch (ConfigException e) {
            e.printStackTrace();
        }

        Pattern pattern = Pattern.compile("(?<class>.+(?:\\.(?<module>[a-zA-Z]+DataModule)))(?:\\:(?<pref>\\d{1,}))?");

        log.info("Loading data modules ...");

        // for each module
        for (String module : modules) {
            // Matcher for regex comparation
            Matcher match;

            // If match with pattern
            if ((match = pattern.matcher(module)).matches()) {

                try {
                    // Reflexive construction with config object argument
                    Constructor constructor = Class.forName(match.group("class")).getConstructor(Config.class);

                    DataModule loadedDataModule = (DataModule) constructor.newInstance(conf);

                    // Init data module
                    loadedDataModule.init();

                    log.trace("Init {} data module", loadedDataModule.getDataModuleName());

                    String priority = match.group("pref");


                    if (priority == null) priority = "0";

                    // If not exist a list of priority modules, we create it
                    if (priority != null && !priorityModules.containsKey(priority))
                        priorityModules.put(priority, new LinkedList<DataModule>());

                    // If exist we will add modules identified for name
                    if (!loadedDataModule.getDataModuleName().matches("(?:AeroSpike|LocalCache)"))
                        priorityModules.get(priority).push(loadedDataModule);

                    loadedModules.put(loadedDataModule.getDataModuleName(), loadedDataModule);

                    log.trace(String.format("Loaded %s module with prioriry %s.", loadedDataModule.getDataModuleName(), priority));

                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                } catch (InstantiationException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }

        }// for

        log.info("Loaded {} modules", loadedModules.size());
        log.trace("Priority modules: {}", priorityModules.toString());

        IncrementalList.linkDataModules(loadedModules);
    }

    // Return number of loaded modules
    public int numberOfLoadedModules() {
        return loadedModules.size();
    }

    // Get full data from data modules
    public Object getFullData(DataModule.FullDataType fullDataType) {

        log.info("Processing full data ...");

        // List of full data of all data modules
        ArrayList<Object> fullDataList = new ArrayList<>();

        CountDownLatch latch = new CountDownLatch(loadedModules.size());

        ExecutorService executorService = Executors.newFixedThreadPool(loadedModules.size());

        // For each data module
        for (DataModule dataModule : loadedModules.values()) {
            // We add latch
            dataModule.addLatch(latch);
            // Select operation
            dataModule.selectOperation(DataModule.Operation.FULL);
            // Select data type
            dataModule.selectFullDataType(fullDataType);
            // And run in single thread
            executorService.submit(dataModule);
        }

        // After we wait results
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        log.info("Getting results ...");

        // Getting results
        for (DataModule module : loadedModules.values()) {

            ArrayList<Map<String, Object>> fullData = (ArrayList<Map<String, Object>>) module.getOperationResult();

            if (!fullData.isEmpty()) {
                fullDataList.addAll(fullData);
            }

        }

        // Return results
        return fullDataList;
    }

    // Set process
    public void setProcess(MalwareREST.PROCESS process) {
        log.info("Set process to {}", process.value);
        this.process = process;
    }

    // For queries
    public Object doQuery(Object query) {

        Map<String, Object> params = (Map<String, Object>) query;

        log.info("Processing query ...");

        // If we have "LocalCache" data module loaded
        if (loadedModules.containsKey("LocalCache")) {

            CountDownLatch latch = new CountDownLatch(params.size());

            // Getting data module named "LocalCache"
            DataModule localCache = loadedModules.get("LocalCache");
            localCache.addLatch(latch);
            ArrayList<Map<String, Object>> cacheResult;

            log.info("Doing query in LocalCache");
            localCache.prepareQuery(params);
            localCache.doQuery();
            cacheResult = (ArrayList<Map<String, Object>>) localCache.getOperationResult();

            for(Map<String, Object> result : cacheResult){
                if(result.containsKey("g_rt_score") && process.compareTo(MalwareREST.PROCESS.COMPLETE) != 0)
                    params.keySet().removeAll(result.keySet());
            }

            log.trace("params : {}", params);

            if (params.size() == 0) {
                log.trace("Query completed in LocalCache data module : {}", cacheResult);

                if (process.compareTo(MalwareREST.PROCESS.AGILE) == 0 && response.compareTo(MalwareREST.RESPONSE.SIMPLE) == 0) {

                    //TODO Review this part!
                    Set<String> filter = new HashSet<>();

                    filter.add("score");
                    filter.add("uploaded");

                    for(DataModule.QUERY_PARAM param : DataModule.QUERY_PARAM.values()){
                        filter.add(param.value);
                    }

                    for(Map<String, Object> result : cacheResult){
                        result.keySet().retainAll(filter);
                    }

                    return cacheResult;
                } else if (process.compareTo(MalwareREST.PROCESS.AGILE) == 0 && response.compareTo(MalwareREST.RESPONSE.VERBOSE) == 0)
                    return cacheResult;

            } else {
                log.info("Query not completed in LocalCache data module!");
                process = MalwareREST.PROCESS.COMPLETE;
            }

        }

        if (process.compareTo(MalwareREST.PROCESS.COMPLETE) == 0) {
            Map<String, ArrayList<Map<String, Object>>> reputationEngine = new HashMap<>();

            log.info("Processing with priority modules ... ");
            // List of priority modules
            for (LinkedList<DataModule> listPriorityModules : priorityModules.values()) {
                CountDownLatch latch = new CountDownLatch(listPriorityModules.size());

                log.trace("Created new latch for {} modules", listPriorityModules.size());

                ExecutorService executorService = null;

                if(listPriorityModules.size() > 0) {
                    executorService = Executors.newFixedThreadPool(listPriorityModules.size());
                }

                for (DataModule dataModule : listPriorityModules) {

                    if(!reputationEngine.containsKey(String.format("rt_%s", dataModule.getDataModuleName().toLowerCase())));
                    reputationEngine.put(String.format("rt_%s", dataModule.getDataModuleName().toLowerCase()), new ArrayList<Map<String, Object>>());

                    dataModule.addLatch(latch);
                    dataModule.prepareQuery(params);
                    dataModule.selectOperation(DataModule.Operation.QUERY);
                    executorService.submit(dataModule);
                }

                log.trace("Waiting for results ...");

                try {
                    latch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                log.trace("Checking results ...");

                for (DataModule dataModule : listPriorityModules) {
                    log.trace("Result for module of {}", dataModule.getDataModuleName());

                    ArrayList<Map<String, Object>> result;

                    if (!(result = (ArrayList) dataModule.getOperationResult()).isEmpty()) {
                        reputationEngine.get(String.format("rt_%s", dataModule.getDataModuleName().toLowerCase())).addAll((ArrayList<Map<String, Object>>) result.clone());
                        log.trace("Added new finalResult for {} with value {}", dataModule.getDataModuleName(), result);
                    }

                }

                log.trace("Reputation engine results : {}", reputationEngine);
            }

            log.info("Updating results for {}", "AeroSpike");

            outputModuleController.updateInOutput("AeroSpike", reputationEngine);

            DataModule localCache = loadedModules.get("LocalCache");
            ArrayList<Map<String, Object>> finalCacheResult = new ArrayList<>();
            localCache.prepareQuery(params);
            localCache.doQuery();
            finalCacheResult = (ArrayList<Map<String, Object>>) localCache.getOperationResult();

            log.trace("Final result : {}", finalCacheResult);

            if (response == MalwareREST.RESPONSE.SIMPLE) {
                Set<String> filter = new HashSet<>();

                filter.add("score");
                filter.add("uploaded");

                for(DataModule.QUERY_PARAM param : DataModule.QUERY_PARAM.values()){
                    filter.add(param.value);
                }

                log.trace("Applying filter : {}", filter);

                for(Map<String, Object> result : finalCacheResult){
                    result.keySet().retainAll(filter);
                }

                return finalCacheResult;

            } else if (response == MalwareREST.RESPONSE.VERBOSE)
                return finalCacheResult;

        }

        Map<String, Object> notFoundScore = new HashMap<>();
        notFoundScore.put("score", -1);
        return notFoundScore;
    }

    public void shutdown() {
        log.trace("shutting down ...");
        outputModuleController.shutdown();

        for (DataModule module : loadedModules.values())
            module.shutdown();

        log.trace("shutdown!");
    }

    public void reload(){

        log.trace("Reloading ...");

        for (Map.Entry<String, DataModule> dataModule: loadedModules.entrySet()){
            dataModule.getValue().reload();
        }

        outputModuleController.reload();

        log.trace("Reloaded!");
    }

}
