package net.redborder.malware.controllers;

import net.redborder.malware.config.Config;
import net.redborder.malware.tasks.ReputationTask;
import net.redborder.malware.tasks.Task;
import net.redborder.malware.tasks.TaskCompletionListener;
import net.redborder.malware.tasks.Worker;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;

public class MalwareTaskController implements TaskCompletionListener {

    private int THREADS;

    private Map<String, Worker> taskList = new HashMap<>();
    private ExecutorService executor = null;
    private ExecutorService privateExcutor = null;
    private Object currentProcessElement;
    private boolean stopConsumer = false;

    PriorityBlockingQueue<Object> priorityBlockingQueue;
    LinkedBlockingQueue<Object> resultBlockingQueue;

    private Worker consumerWorker;

    public MalwareTaskController(Config conf, PriorityBlockingQueue<Object> priorityBlockingQueue, LinkedBlockingQueue<Object> resultBlockingQueue) {
        THREADS = conf.getInt("malware.task.controller.threads", 5);
        executor = Executors.newFixedThreadPool(THREADS);
        privateExcutor = Executors.newSingleThreadExecutor();

        this.priorityBlockingQueue = priorityBlockingQueue;
        this.resultBlockingQueue = resultBlockingQueue;

    }

    public void start() {
        privateExcutor.submit(new PriorityQueueConsumer());
    }

    public void runTask(Task task) {

        final Worker thread = new Worker(task);
        this.taskList.put(thread.getTask().getTaskName(), thread);

        executor.submit(thread);
    }

    public void runTask(Task task, TaskCompletionListener listener) {
        final Worker thread = new Worker(task);

        thread.addTaskCompletionListener(listener);
        this.taskList.put(thread.getTask().getTaskName(), thread);

        executor.submit(thread);
    }

    public void pauseTask(String taskName) {
        this.taskList.get(taskName).pauseTask();
    }

    public void resumetask(String taskName) {
        this.taskList.get(taskName).resumeTask();
    }

    public String getTaskStatus(String taskName) {
        return this.taskList.containsKey(taskName) ? this.taskList.get(taskName).getCurrentStatusString() : "Task not found!";
    }

    public Object getCurrentProcessElement() {
        return currentProcessElement;
    }

    public String getTasksStatus() {

        StringBuilder sb = new StringBuilder();

        for (Worker thread : this.taskList.values())
            sb.append(String.format("Task id : %s %n\tStatus : %s%n", thread.getTask().getTaskName(), thread.getCurrentStatusString()));

        return sb.toString();
    }

    public void pauseTasks() {
        for (Worker thread : this.taskList.values())
            thread.pauseTask();
    }

    public void resumeTasks() {
        for (Worker thread : this.taskList.values())
            thread.resumeTask();
    }

    public void shutdown() {
        this.stopConsumer = true;

        System.out.println(taskList.values().toArray());

        // Cancell tasks
        if (!taskList.isEmpty())
            for (Worker worker : taskList.values())
                if (!worker.isComplete())
                    worker.cancelTask();
        // Clear task list
        this.taskList.clear();
        this.taskList = null;
        // shutdown executor
        executor.shutdown();
    }

    @Override
    public void taskCompleted(Worker task) {

    }

    private class PriorityQueueConsumer implements Runnable {

        @Override
        public void run() {
            while (!stopConsumer) {

                Object priorityElement = null;

                try {
                    priorityElement = priorityBlockingQueue.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                runTask(new ReputationTask(Config.createConfig(), Config.createConfig()));
            }
        }
    }

}
