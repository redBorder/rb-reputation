package net.redborder.malware;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.AeroSpikeManager;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;

public class MalwareController {

    private static final Logger log = LoggerFactory.getLogger(MalwareController.class);

    LinkedBlockingQueue<Map<String, Object>> queue;
    MalwareRevisionList revisionList;
    Config conf;
    Timer timerTask;
    AeroSpikeManager aerospikeManager;
    ZkUtils zkUtils = null;
    CuratorFramework curatorClient;

    int MS = 10000;
    int OFFSET = 2;

    private final String NAMESPACE = "malware";
    private final String COLLECTION = "rb_malware";

    public MalwareController(Config conf, LinkedBlockingQueue<Map<String, Object>> queue) {

        this.conf = conf;

        this.queue = queue;

        try {

            init();

            this.aerospikeManager = new AeroSpikeManager(conf);
            // Init Curator client
            curatorClient = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            curatorClient.start();

            zkUtils = new ZkUtils(curatorClient, String.format("/%s", conf.get("malware.zkWorkspace")));
            zkUtils.registerNode();

            revisionList = new MalwareRevisionList(2, queue);
            MalwareREST.setController(this);

        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (ConfigException e) {
            e.printStackTrace();
        }


    }

    public void start(){

        while(!zkUtils.checkIfExist("/malware_list/leader")) {

            log.info("Checking if leader is selected...");

            // Am I the leader?
            if (zkUtils.isLeader()) { // Yes

                // Create node "leader"
                zkUtils.createEphemeralNodeIfNotExist("leader");
                // Create node "revision"
                zkUtils.createEphemeralNodeIfNotExist("revision");

                zkUtils.writeJsonInNode("revision", String.format("revision=%d", revisionList.getRevisionNumber()));

                try {
                    zkUtils.writeJsonInNode("leader", String.format("leadeR=%s", InetAddress.getLocalHost().getCanonicalHostName()));
                } catch (UnknownHostException e) {
                    e.printStackTrace();
                }

            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            initContinuousQuery();
        }

        if(!zkUtils.isLeader()) {
            // Get revision
            int revision = Integer.valueOf(zkUtils.readJsonFrom("/malware_list/revision").get("revision"));
            log.info("Set revision to {}", revision);
            System.out.println("Revision : " + revision);

            Client client = Client.create();

            ObjectMapper mapper = new ObjectMapper();

            String list = client.resource(String.format("http://%s:%d/malware/revision/%d", zkUtils.readJsonFrom("/malware_list/leader").get("leader"), MalwareREST.getPort(), revision)).accept("application/json").get(ClientResponse.class).getEntity(String.class);

            ArrayList<Map<String, Object>> currentRevision = null;

            try {
                currentRevision = mapper.readValue(list, new TypeReference<ArrayList<Map<String, Object>>>() {
                });
            } catch (IOException e) {
                e.printStackTrace();
            }

            revisionList.createNewRevision(currentRevision, revision);

            // Put watcher on children node
            TaskWatcher taskWatcher = new TaskWatcher();
            zkUtils.watcherChildren(taskWatcher, "/malware_list/leader");
            log.info("Added watcher for node change to /malware_list/leader");

            zkUtils.watcherData(taskWatcher, "/malware_list/revision");
            log.info("Added watcher for data change to /malware_list/revision");
        }

    }

    private void init() throws ConfigException {
        MS = conf.getInt("malware.query.ms");
        OFFSET = conf.getInt("malware.revision.offset");
    }

    public void shutdown() {
        zkUtils.shutdown();
        aerospikeManager.closeClient();
        timerTask.cancel();
    }

    public ArrayList<Map<String, Object>> generateTotal() {
        return revisionList.getTotal();
    }

    public ArrayList<Map<String, Object>> generateCurrentRevision() {
        return revisionList.getCurrentRevision();
    }

    public ArrayList<Map<String, Object>> generateRevision(int revisionNum) {
        return revisionList.getRevNum(revisionNum);
    }

    public int getRevisionNumber() {
        return revisionList.getRevisionNumber();
    }

    public Map<String, Object> getDataForSHA(String sha) {
        return aerospikeManager.get(NAMESPACE, COLLECTION, sha);
    }

    private void initContinuousQuery(){ // If the node isn't leader!!
        timerTask = new Timer();
        timerTask.schedule(new GenerateRevisionTask(), 0, MS);
    }

    private class GenerateRevisionTask extends TimerTask {
        @Override
        public void run() {
            ArrayList<Map<String, Object>> total = aerospikeManager.getList("malware", "rb_malware");

            for (Map<String, Object> m : total) {
                m.remove("cuckoo_before");
                m.put("action", "create");
            }

            revisionList.createTotal(total);

            revisionList.finishCurrentRevision();
        }
    }

    private static class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    break;

                case NodeDataChanged:
                    log.info("Data from node {} changed!", watchedEvent.getPath());
                    break;
            }

        }
    }

}
