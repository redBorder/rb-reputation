package net.redborder.malware.tasks;

import java.util.concurrent.CopyOnWriteArrayList;

public class Worker implements Runnable {

    public enum Status {
        NOT_STARTED, RUNNING, PAUSED, CANCELLING, CANCELLED, COMPLETED, FAILED
    }

    protected Task runningTask;

    protected volatile Status currentStatus;

    protected TaskMonitor taskMonitor;

    protected Object finalResult;

    protected long taskStartTime;

    protected long taskEndTime;

    protected long threadID;

    protected CopyOnWriteArrayList<TaskListener> listeners = new CopyOnWriteArrayList<>();

    public Worker(Task toRun) {
        this.runningTask = toRun;
        this.currentStatus = Status.NOT_STARTED;
        this.taskMonitor = new StandardTaskMonitor();
        this.taskMonitor.setCurrentActivityDescription(String.format("Running task %s", toRun));
    }

    @Override
    public void run() {

        threadID = Thread.currentThread().getId();

        TimingUtils.enablePreciseTiming();

        this.taskStartTime = TimingUtils.getNanoCPUTimeOfCurrentThread();

        try {
            this.currentStatus = Status.RUNNING;
            this.finalResult = this.runningTask.doTask(taskMonitor);
            this.currentStatus = this.taskMonitor.isCancelled() ? Status.CANCELLED : Status.COMPLETED;
        } catch (Throwable ex) {
            this.currentStatus = Status.FAILED;
        }

        this.taskEndTime = TimingUtils.getNanoCPUTimeOfCurrentThread();

        fireTaskCompleted();

    }

    public synchronized void pauseTask() {
        if (this.currentStatus == Status.RUNNING) {
            this.taskMonitor.requestPause();
            this.currentStatus = Status.PAUSED;
            fireTaskPaused();
        }
    }

    public synchronized void resumeTask() {
        if (this.currentStatus == Status.PAUSED) {
            this.taskMonitor.requestResume();
            this.currentStatus = Status.RUNNING;
            fireTaskResumed();
        }
    }

    public synchronized void cancelTask() {
        if (this.currentStatus == Status.RUNNING || this.currentStatus == Status.PAUSED) {
            this.runningTask.shutdown();
            this.taskMonitor.requestCancel();
            this.currentStatus = Status.CANCELLING;
            fireTaskCancelled();
        }
    }

    public double getCPUSecondsElapsed() {
        double secondsElapsed = 0.0;
        if (this.currentStatus == Status.NOT_STARTED) {
            secondsElapsed = 0.0;
        } else if (isComplete()) {
            secondsElapsed = TimingUtils.nanoTimeToSeconds(this.taskEndTime
                    - this.taskStartTime);
        }

        return secondsElapsed > 0.0 ? secondsElapsed : 0.0;
    }

    public Task getTask() {
        return this.runningTask;
    }

    public String getCurrentStatusString() {
        switch (this.currentStatus) {
            case NOT_STARTED:
                return "not started";
            case RUNNING:
                return "running";
            case PAUSED:
                return "paused";
            case CANCELLING:
                return "cancelling";
            case CANCELLED:
                return "cancelled";
            case COMPLETED:
                return "completed";
            case FAILED:
                return "failed";
        }
        return "unknown";
    }

    public String getCurrentActivityString() {
        return (isComplete() || this.currentStatus == Status.NOT_STARTED ? "" : this.taskMonitor.getCurrentActivityDescription());
    }

    public boolean isComplete() {
        return ((this.currentStatus == Status.CANCELLED) ||
                (this.currentStatus == Status.COMPLETED) ||
                (this.currentStatus == Status.FAILED));
    }

    public Object getFinalResult() {
        if (finalResult == null)
            finalResult = new Object();

        return finalResult;
    }

    public void addTaskCompletionListener(TaskListener tcl) {
        this.listeners.add(tcl);
    }

    public void removeTaskCompletionListener(TaskListener tcl) {
        this.listeners.remove(tcl);
    }

    protected void fireTaskCompleted() {
        for (TaskListener listener : this.listeners)
            listener.taskCompleted(this);
    }

    protected void fireTaskCancelled(){
        for (TaskListener listener : this.listeners)
            listener.taskCancelled(this);
    }

    protected void fireTaskPaused(){
        for (TaskListener listener : this.listeners)
            listener.taskPaused(this);
    }

    protected void fireTaskResumed() {
        for (TaskListener listener : this.listeners)
            listener.taskResumed(this);
    }

}
