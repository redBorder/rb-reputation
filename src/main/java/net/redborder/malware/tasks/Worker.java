package net.redborder.malware.tasks;

import java.util.concurrent.CopyOnWriteArrayList;

public class Worker implements Runnable {

    public enum Status{
        NOT_STARTED, RUNNING, PAUSED, CANCELLING, CANCELLED, COMPLETED, FAILED
    }

    protected Task runningTask;

    protected volatile Status currentStatus;

    protected TaskMonitor taskMonitor;

    protected Object finalResult;

    protected long taskStartTime;

    protected long taskEndTime;

    protected long threadID;

    protected CopyOnWriteArrayList<TaskCompletionListener> completionListeners = new CopyOnWriteArrayList<>();

    public Worker(Task toRun){
        this.runningTask = toRun;
        this.currentStatus = Status.NOT_STARTED;
        this.taskMonitor = new StandardTaskMonitor();
        this.taskMonitor.setCurrentActivityDescription(String.format("Running task %s", toRun));
    }

    public void run(){

        threadID = Thread.currentThread().getId();

        TimingUtils.enablePreciseTiming();
        this.taskStartTime = TimingUtils.getNanoCPUTimeOfCurrentThread();

        try{
            this.currentStatus = Status.RUNNING;
            this.runningTask.doTask(taskMonitor);
            this.currentStatus = this.taskMonitor.isCancelled() ? Status.CANCELLED : Status.COMPLETED;
        }catch(Throwable ex){
            this.currentStatus = Status.FAILED;
        }

        this.taskEndTime = TimingUtils.getNanoCPUTimeOfCurrentThread();

        fireTaskCompleted();

    }

    public long getThreadID(){
        return threadID;
    }

    public synchronized void pauseTask(){
        if(this.currentStatus == Status.RUNNING){
            this.taskMonitor.requestPause();
            this.currentStatus = Status.PAUSED;
        }
    }

    public synchronized void resumeTask(){
        if(this.currentStatus == Status.PAUSED){
            this.taskMonitor.requestResume();
            this.currentStatus = Status.RUNNING;
        }
    }

    public synchronized void cancelTask(){
        if(this.currentStatus == Status.RUNNING ||this.currentStatus == Status.PAUSED){
            this.runningTask.shutdown();
            this.taskMonitor.requestCancel();
            this.currentStatus = Status.CANCELLING;
        }
    }

    public double getCPUSecondsElapsed() {
        double secondsElapsed = 0.0;
        if (this.currentStatus == Status.NOT_STARTED) {
            secondsElapsed = 0.0;
        } else if (isComplete()) {
            secondsElapsed = TimingUtils.nanoTimeToSeconds(this.taskEndTime
                    - this.taskStartTime);
        }

        return secondsElapsed > 0.0 ? secondsElapsed : 0.0;
    }

    public Task getTask(){
        return this.runningTask;
    }

    public String getCurrentStatusString() {
        switch (this.currentStatus) {
            case NOT_STARTED:
                return "not started";
            case RUNNING:
                return "running";
            case PAUSED:
                return "paused";
            case CANCELLING:
                return "cancelling";
            case CANCELLED:
                return "cancelled";
            case COMPLETED:
                return "completed";
            case FAILED:
                return "failed";
        }
        return "unknown";
    }

    public String getCurrentActivityString(){
        return (isComplete() || this.currentStatus == Status.NOT_STARTED ? "" : this.taskMonitor.getCurrentActivityDescription());
    }

    public boolean isComplete(){
        return ((this.currentStatus == Status.CANCELLED) ||
                (this.currentStatus == Status.COMPLETED) ||
                (this.currentStatus == Status.FAILED));
    }

    public Object getFinalResult(){
        if(finalResult == null)
            finalResult = new Object();

        return finalResult;
    }

    public void addTaskCompletionListener(TaskCompletionListener tcl){
        this.completionListeners.add(tcl);
    }

    public void removeTaskCompletionListener(TaskCompletionListener tcl){
        this.completionListeners.remove(tcl);
    }

    protected void fireTaskCompleted(){
        for(TaskCompletionListener listener : this.completionListeners)
            listener.taskCompleted(this);
    }

}
