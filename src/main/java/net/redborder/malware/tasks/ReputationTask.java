package net.redborder.malware.tasks;

import net.redborder.malware.config.Config;
import net.redborder.malware.controllers.MalwareDataModuleController;
import net.redborder.malware.controllers.MalwareOutputModuleController;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;

public class ReputationTask extends AbstractTask implements TaskCompletionListener{

    private MalwareDataModuleController dataModuleController;
    private MalwareOutputModuleController outputController;

    private Worker workerConsumer;
    private ExecutorService consumerExecutor;

    private PriorityBlockingQueue<Object> priorityBlockingQueue;
    private LinkedBlockingQueue<Object> resultBlokingQueue;

    private Object petition;

    public ReputationTask(Config confDataModule, Config confOutputModule, PriorityBlockingQueue<Object> priorityBlockingQueue, LinkedBlockingQueue<Object> resultBlokingQueue){

        dataModuleController = new MalwareDataModuleController(confDataModule);
        outputController = new MalwareOutputModuleController(confOutputModule);

        this.priorityBlockingQueue = priorityBlockingQueue;
        this.resultBlokingQueue = resultBlokingQueue;

        workerConsumer= new Worker(new Consumer(priorityBlockingQueue));

        consumerExecutor = Executors.newSingleThreadExecutor();
    }

    @Override
    protected Object doTaskImpl(TaskMonitor monitor) {

        consumerExecutor.submit(workerConsumer);

        return petition;
    }

    @Override
    protected void shutdownImpl() {
        consumerExecutor.shutdown();
    }

    @Override
    public Class<?> getTaskResultType() {
        return null;
    }

    @Override
    public void taskCompleted(Worker task) {
        try {
            resultBlokingQueue.put(task.getFinalResult());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
