package net.redborder.malware.tasks;

import java.util.concurrent.CopyOnWriteArrayList;

public class TaskThread extends Thread {

    public static enum Status{
        NOT_STARTED, RUNNING, PAUSED, CANCELLING, CANCELLED, COMPLETED, FAILED
    }

    protected Task runningTask;

    protected volatile Status currentStatus;

    protected TaskMonitor taskMonitor;

    protected Object finalResult;

    protected long taskStartTime;

    protected long taskEndTime;

    CopyOnWriteArrayList<TaskCompletionListener> completionListeners = new CopyOnWriteArrayList<>();

    public TaskThread(Task toRun){
        this.runningTask = toRun;
        this.currentStatus = Status.NOT_STARTED;
        this.taskMonitor = new StandardTaskMonitor();
        this.taskMonitor.setCurrentActivityDescription(String.format("Running task %s", toRun));
    }

    public void run(){

        try{
            this.currentStatus = Status.RUNNING;
            this.runningTask.doTask(taskMonitor);

        }catch(Throwable ex){
            this.currentStatus = Status.FAILED;
        }

        fireTaskCompleted();

    }

    public synchronized void pauseTask(){
        if(this.currentStatus == Status.RUNNING){
            this.taskMonitor.requestPause();
            this.currentStatus = Status.PAUSED;
        }
    }

    public synchronized void resumeTask(){
        if(this.currentStatus == Status.PAUSED){
            this.taskMonitor.requestResume();
            this.currentStatus = Status.RUNNING;
        }
    }

    public synchronized void cancelTask(){
        if(this.currentStatus == Status.RUNNING ||this.currentStatus == Status.PAUSED){
            this.taskMonitor.requestCancel();
            this.currentStatus = Status.CANCELLING;
        }
    }

    public Task getTask(){
        return this.runningTask;
    }

    public String getCurrentStatusString() {
        switch (this.currentStatus) {
            case NOT_STARTED:
                return "not started";
            case RUNNING:
                return "running";
            case PAUSED:
                return "paused";
            case CANCELLING:
                return "cancelling";
            case CANCELLED:
                return "cancelled";
            case COMPLETED:
                return "completed";
            case FAILED:
                return "failed";
        }
        return "unknown";
    }

    public String getCurrentActivityString(){
        return (isComplete() || this.currentStatus == Status.NOT_STARTED ? "" : this.taskMonitor.getCurrentActivityDescription());
    }

    public boolean isComplete(){
        return ((this.currentStatus == Status.CANCELLED) ||
                (this.currentStatus == Status.COMPLETED) ||
                (this.currentStatus == Status.FAILED));
    }

    public Object getFinalResult(){
        return finalResult;
    }

    public void addTaskCompletionListener(TaskCompletionListener tcl){
        this.completionListeners.add(tcl);
    }

    public void removeTaskCompletionListener(TaskCompletionListener tcl){
        this.completionListeners.remove(tcl);
    }

    protected void fireTaskCompleted(){
        for(TaskCompletionListener listener : this.completionListeners)
            listener.taskCompleted(this);
    }

}
