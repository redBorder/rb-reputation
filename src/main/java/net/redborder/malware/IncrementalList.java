package net.redborder.malware;

import net.redborder.malware.config.Config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class IncrementalList {

    public enum List{
        REVISION, INCREMENT, STORE
    }

    // Logging
    private static final Logger log = LoggerFactory.getLogger(IncrementalList.class);

    // ArrayList with all JSONs
    private static ArrayList<Map<String, Object>> totalList = new ArrayList<>();

    // ArrayList with current incremental
    private static ArrayList<Map<String, Object>> incremental = new ArrayList<>();

    // Store of incrementals
    private static Map<String, ArrayList<Map<String, Object>>> incrementalList = new HashMap<>();

    // Store of revisions
    private static Map<String, Map<String, ArrayList<Map<String, Object>>>> revisionStore = new HashMap<>();

    // Current revision
    private static AtomicInteger revision = new AtomicInteger(0);

    // Current increment
    private static AtomicInteger increment = new AtomicInteger(0);

    // Number of enable revisions
    private static int OFFSET = 2;

    // Milliseconds to close incremental list
    private static long MILLIS_INCREMENTAL = TimeUnit.MINUTES.toMillis(15);

    // Milliseconds to close revision list
    private static long MILLIS_REVISION = TimeUnit.DAYS.toMillis(1);

    // Timer for generate revision
    private static ScheduledExecutorService generateRevision = Executors.newSingleThreadScheduledExecutor();
    private static ScheduledFuture currentGenerateRevisionTask;

    // Timer for generate incremental
    private static ScheduledExecutorService generateIncremental = Executors.newSingleThreadScheduledExecutor();
    private static ScheduledFuture currentGenerateIncrementalTask;
    public static String getRevisionStore(){
        return revisionStore.keySet().toString();
    }

    public static String getCurrent(List list){

        switch(list) {
            case REVISION:
                return String.valueOf(revision);
            case INCREMENT:
                return String.valueOf(increment);
            case STORE:
                return String.valueOf(revisionStore);
        }

        return null;

    }

    public static void init(Config config){
        OFFSET = config.getInt("malware.revisionlist.offset", 2);
        MILLIS_INCREMENTAL = config.getTime("malware.incrementallist.incremental.time", "15M");
        System.out.println("Set incremental time to : " + MILLIS_INCREMENTAL);
        MILLIS_REVISION = config.getTime("malware.incrementallist.revision.time", "1D");
        System.out.println("Set revision time to : " + MILLIS_REVISION);
        resetIncrementalList();

        revisionStore.put(String.format("%d", revision.get()), incrementalList);
    }

    public static void closeIncremental(){
        incrementalList.put(String.format("%d.%d", revision.get(), increment.get()), (ArrayList<Map<String, Object>>) incremental.clone());
        incremental.clear();
        increment.incrementAndGet();
    }

    public static void closeRevision(){
        revisionStore.put(String.format("%d", revision.get()), (Map<String, ArrayList<Map<String, Object>>>) ((HashMap) incrementalList).clone());
        revision.incrementAndGet();
        incrementalList.clear();
        increment.set(0);
        revisionStore.put(String.format("%d", revision.get()), incrementalList);

        if(revisionStore.size() > OFFSET)
            revisionStore.remove(String.format("%s", (revision.get() - OFFSET)));

    }

    public static void start(){
        currentGenerateRevisionTask = generateRevision.scheduleAtFixedRate(new generateRevision(), 0L, MILLIS_REVISION, TimeUnit.MILLISECONDS);
        currentGenerateIncrementalTask = generateIncremental.scheduleAtFixedRate(new generateIncremental(), 0L, MILLIS_INCREMENTAL, TimeUnit.MILLISECONDS);
    }

    public static void stop(){
        if(currentGenerateIncrementalTask != null)
            currentGenerateIncrementalTask.cancel(true);

        if(currentGenerateRevisionTask != null)
            currentGenerateRevisionTask.cancel(true);
    }

    public static void shutdown(){
        stop();
        generateIncremental.shutdown();
        generateRevision.shutdown();
    }

    public static void resetIncrementalList(){
        stop();
        revisionStore.clear();
        incremental.clear();
        incrementalList.clear();
        revision.set(1);
        increment.set(0);
    }

    private static class generateRevision implements Runnable {

        @Override
        public void run() {
            System.out.println("Closing revision : " + revision);
            closeRevision();
        }
    }


    private static class generateIncremental implements Runnable {

        @Override
        public void run() {
            System.out.println("Closing incremental : " + increment);
            closeIncremental();
        }
    }


}
