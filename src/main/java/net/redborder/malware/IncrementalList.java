package net.redborder.malware;

import net.redborder.malware.config.Config;
import net.redborder.malware.controllers.MalwareController;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class IncrementalList {

    public enum Last{
        REVISION, INCREMENTAL
    }

    public enum List{
        INCREMENTAL, REVISION
    }

    private static Map<String, DataModule> loadedModules = null;

    // Logging
    private static final Logger log = LoggerFactory.getLogger(IncrementalList.class);
    private static final Logger audit = LoggerFactory.getLogger("audit");

    // ArrayList with all JSONs
    private static ArrayList<Map<String, Object>> totalList = new ArrayList<>();

    // ArrayList with current incremental (JSONs)
    private static ArrayList<Map<String, Object>> incremental = new ArrayList<>();

    // Store of incrementals (i.1, i.2, i.3, ··· , i.(N-2), i.(N-1), i.N ; i € [1 ... M])
    private static Map<String, ArrayList<Map<String, Object>>> incrementalList = new HashMap<>();

    // Store of revisions (1, 2, 3, ···, N-2, N-1, N)
    private static Map<String, Map<String, ArrayList<Map<String, Object>>>> revisionStore = new HashMap<>();

    // Current Revision
    private static int currentRevision = 1;

    // Current Increment
    private static int currentIncrement = 0;

    // Last revision closed
    private static int lastRevision = 0;

    // Last incremental closed
    private static int lastIncremental = 0;

    // Number of enable revisions
    private static int OFFSET = 2;

    // Milliseconds to close incremental list
    private static long MILLIS_INCREMENTAL = TimeUnit.MINUTES.toMillis(15);

    // Milliseconds to close currentRevision list
    private static long MILLIS_REVISION = TimeUnit.DAYS.toMillis(1);

    // Matches for close
    private static long MATCHES = 0;

    // Count of match
    private static long COUNT = 0;

    // Timer for generate incremental and currentRevision
    private static ScheduledExecutorService generatedIncrementalList = Executors.newSingleThreadScheduledExecutor();
    // Future of incremental list (Runnable)
    private static ScheduledFuture currentIncrementalList;

    public static String getRevisionStore(){
        return revisionStore.keySet().toString();
    }

    public static String getValue(Last value){
            switch(value){
                case REVISION:
                    return String.format("%d", currentRevision);
                case INCREMENTAL:
                    return String.format("%d.%d", currentRevision, currentIncrement - 1);
            }

        return "ERROR in last argument.";

    }

    public static Object getCurrent(List list){
        if(!revisionStore.isEmpty())
            switch(list) {
                case REVISION:
                    return revisionStore.keySet();        // Current number of currentRevision   [X]
                case INCREMENTAL:
                    return incrementalList.keySet();       // Current number of incremental [Y]
            }
        else
            return "N/A";

        return "ERROR in list argument.";
    }

    public static void linkDataModules(Map<String, DataModule> modules){
        loadedModules = modules;
    }

    public static void setTotalList(ArrayList<Map<String, Object>> newTotal){
        totalList = newTotal;
    }

    public static void setIncrementalList(ArrayList<Map<String, Object>> newIncremental){
        incremental = newIncremental;
    }

    public static ArrayList<Map<String, Object>> getList(String id){

        Pattern pattern = Pattern.compile("(?<incremental>(?<revision>\\d+)(?:\\.\\d+)?)");

        Matcher matcher;

        String incremental = "";

        String revision = "";

        if((matcher = pattern.matcher(id)).matches()){

            incremental = matcher.group("incremental");
            revision = matcher.group("revision");

            if (incremental != null && !incremental.isEmpty()){
                if(revisionStore.containsKey(revision) && revisionStore.get(revision).containsKey(incremental))
                    return revisionStore.get(revision).get(incremental);
                else if(incrementalList.containsKey(incremental))
                    return incrementalList.get(incremental);
            }

        }

        return new ArrayList<>();

    }

    public static void init(Config config){
        audit.info("Initializing incremental list ... ");
        OFFSET = config.getInt("malware.incrementallist.offset", 2);
        log.info("Set incremental offset to : {}", OFFSET);
        MILLIS_INCREMENTAL = config.getTime("malware.incrementallist.incremental.ttl", "15M");
        log.info("Set incremental time to : {}", MILLIS_INCREMENTAL);
        MILLIS_REVISION = config.getTime("malware.incrementallist.revision.ttl", "1D");
        log.info("Set currentRevision time to : {}", MILLIS_REVISION);

        int result = Long.compare(MILLIS_REVISION, MILLIS_INCREMENTAL);

        if(result < 0){
            // Revision must be greater than incremental -> Exception
            try {
                throw new Exception("TTL currentRevision must be greater than TTL incremental");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else{
            MATCHES = MILLIS_REVISION/MILLIS_INCREMENTAL;
            log.info("A Revision will have {} incrementals", MATCHES);
        }

        // Reset incremental list
        resetIncrementalList();

//        revisionStore.put(String.format("%d", currentRevision), incrementalList);
    }

    public static void closeIncremental(){

        for(DataModule module : loadedModules.values()){
            log.info("Getting incremental for data module : {}", module.getDataModuleName());
            incremental.addAll((ArrayList<Map<String, Object>>) module.getIncremental());
        }

        incrementalList.put(String.format("%d.%d", currentRevision, currentIncrement), (ArrayList<Map<String, Object>>) incremental.clone());
        log.info("Added new incremental with value {}.{}", currentRevision, currentIncrement);
        audit.info("Closed incremental {}", String.format("%d.%d", currentRevision, currentIncrement));

        Map<String, Object> json = new HashMap<>();
        json.put("incremental", String.format("%d.%d", currentRevision, currentIncrement));
        MalwareController.writeInRevision(json);

        currentIncrement++;


    }

    public static void closeRevision(){

        revisionStore.put(String.format("%d", currentRevision), (Map<String, ArrayList<Map<String, Object>>>) ((HashMap) incrementalList).clone());
        audit.info("Closed revision {}", currentRevision);

        if(revisionStore.size() > OFFSET) {
            revisionStore.remove(String.format("%s", (currentRevision - OFFSET)));
            log.info("Removed revision {}", currentRevision - OFFSET);
            audit.info("Removed revision {} from list", currentRevision - OFFSET);
        }

        currentRevision++;
        currentIncrement = 0;
//        revisionStore.put(String.format("%d", currentRevision), incrementalList);

    }

    public static void start(){
        generatedIncrementalList.scheduleWithFixedDelay(new Generator(), 0L, MILLIS_INCREMENTAL, TimeUnit.MILLISECONDS);
        log.info("Incremental list started!");
        audit.info("Incremental list is running!");
    }

    public static void stop(){

        if(currentIncrementalList != null)
            currentIncrementalList.cancel(true);

        audit.info("Incremental list is stopped");

    }

    public static void shutdown(){
        audit.info("Shutting down incremental list ... ");
        stop();
        generatedIncrementalList.shutdown();
    }

    public static void setRevision(int newRevision){
        currentRevision = newRevision;
    }

    public static void setIncremental(int newRevision, int newIncremental){
        currentRevision = newRevision;
        currentIncrement = newIncremental;
    }

    public static void resetIncrementalList(){
        stop();
        revisionStore.clear();
        incremental.clear();
        incrementalList.clear();
        currentRevision = 1;
        currentIncrement = 1;
        COUNT = 0;
    }

    private static class Generator implements Runnable {

        @Override
        public void run() {

            log.info("Closing incremental : {}", currentIncrement);
            closeIncremental();
            COUNT++;

            if (COUNT % MATCHES == 0){
                log.info("Closing revision : {}", currentRevision);
                lastRevision = currentRevision;
                lastIncremental = currentIncrement - 1;

                closeRevision();
            }
        }
    }


}
