package net.redborder.malware;

import com.rits.cloning.Cloner;
import net.redborder.malware.config.Config;
import net.redborder.malware.controllers.MalwareController;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.Lock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import static ch.lambdaj.Lambda.*;


public class IncrementalList {

    public enum Last {
        REVISION, INCREMENTAL
    }

    private static Map<String, DataModule> loadedModules = null;

    // Logging
    private static final Logger log = LoggerFactory.getLogger(IncrementalList.class);
    private static final Logger audit = LoggerFactory.getLogger("audit");

    private static Config config;

    // ArrayList with current incremental (JSONs)
    private static ArrayList<Map<String, Object>> incremental = new ArrayList<>();

    // Store of incrementals (i.1, i.2, i.3, ··· , i.(N-2), i.(N-1), i.N ; i € [1 ... N])
    private static Map<Integer, ArrayList<Map<String, Object>>> incrementalList = new HashMap<>();

    private static ArrayList<Map<String, Object>> totalList = new ArrayList<>();

    // Store of revisions (1, 2, 3, ···, N-2, N-1, N)
    private static Map<Integer, Map<Integer, ArrayList<Map<String, Object>>>> revisionStore = new HashMap<>();

    // Current Revision
    private static int currentRevision = 1;

    // Current Increment
    private static int currentIncrement = 0;

    // Last revision closed
    private static int lastRevision = 0;

    // Last incremental closed
    private static int lastIncremental = 0;

    // Number of enable revisions
    private static int OFFSET = 2;

    // Milliseconds to close incremental list
    private static long MILLIS_INCREMENTAL = TimeUnit.MINUTES.toMillis(15);

    // Milliseconds to close currentRevision list
    private static long MILLIS_REVISION = TimeUnit.HOURS.toMillis(1);

    // Matches for close revision list
    private static long MATCHES = 0;

    // Count of match
    private static long COUNT = 0;

    // Timer for generate incremental and currentRevision
    private static ScheduledExecutorService generatedIncrementalList = Executors.newSingleThreadScheduledExecutor();

    // Future of incremental list (Runnable)
    private static ScheduledFuture currentIncrementalList;

    // Cloner for deep copy
    private static Cloner cloner = new Cloner();

    private static Semaphore syncTotalLock = new Semaphore(1);

    public static String getRevisionStore() {
        return revisionStore.keySet().toString();
    }

    public static String getValue(Last value) {
        switch (value) {
            case REVISION:
                return String.format("%d", currentRevision);
            case INCREMENTAL:
                return String.format("%d.%d", lastRevision, lastIncremental);
        }

        return "ERROR in last argument.";

    }

    public static Object getCurrent() {
            return String.format("%d.%d", currentRevision, currentIncrement);
    }

    public static void linkDataModules(Map<String, DataModule> modules) {

        try {
            syncTotalLock.acquire();

            if(loadedModules == null)
                loadedModules = modules;

            if(totalList.isEmpty()) {
                log.info("Creating total list firstime");
                totalList = (ArrayList<Map<String, Object>>) cloner.deepClone(loadedModules.get("AeroSpike").getFullData());
                log.info("Loaded " + totalList.size() + " registers");
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {

            syncTotalLock.release();
        }

    }

    public static void setIncrementalList(ArrayList<Map<String, Object>> newIncremental) {
        incrementalList.put(lastIncremental, (ArrayList<Map<String, Object>>) newIncremental.clone());
        log.info("Added new incremental ({})", String.format("%d.%d", currentRevision, currentIncrement));
    }

    public static Map<String, Object> getList(String id) {

        Pattern pattern = Pattern.compile("(?:(?<revision>\\d+)\\.(?<incremental>\\d+))");

        Matcher matcher;

        Integer incremental = -1;

        Integer revision = -1;

        log.trace("Id : {}", id);

        Map<String, Object> incrementalList = new HashMap<>();

        if ((matcher = pattern.matcher(id)).matches()) {
            log.trace("Getting incremental " + id);
            incremental = Integer.valueOf(matcher.group("incremental"));
            revision = Integer.valueOf(matcher.group("revision"));

            log.trace("Revision : " + revision);
            log.trace("Incremental : " + incremental);

            if (revisionStore.containsKey(revision) && revisionStore.get(revision).containsKey(incremental)){
                log.trace("Exist incremental!");
                incrementalList.put("correct", true);
                incrementalList.put("data", revisionStore.get(revision).get(incremental));
            }else{
                log.trace("Not exist incremental!");
                incrementalList.put("correct", false);
                incrementalList.put("data", new ArrayList<>());
            }
        }

        return incrementalList;

    }

    public static void init(Config conf) {
        config = conf;
        audit.info("Initializing incremental list ... ");
        // Reload config
        reload();
        // Reset incremental list
        resetIncrementalList();
    }

    public static void reload() {
        OFFSET = config.getInt("malware.incrementallist.offset", 2);
        log.trace("Set incremental offset to : {}", OFFSET);
        MILLIS_INCREMENTAL = config.getTime("malware.incrementallist.incremental.ttl", "15M");
        log.trace("Set incremental time to : {}", MILLIS_INCREMENTAL);
        MILLIS_REVISION = config.getTime("malware.incrementallist.revision.ttl", "1D");
        log.trace("Set currentRevision time to : {}", MILLIS_REVISION);

        int result = Long.compare(MILLIS_REVISION, MILLIS_INCREMENTAL);

        if (result < 0) {
            // Revision must be greater than incremental -> Exception
            try {
                throw new Exception("TTL revision must be greater than TTL incremental");
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            MATCHES = MILLIS_REVISION / MILLIS_INCREMENTAL;
            log.info("A Revision will have {} incrementals", MATCHES);
        }
    }

    public static void closeIncremental() {
        log.info("{}", String.format("Closing incremental %d of revision %d", currentIncrement, currentRevision));

        for (DataModule module : loadedModules.values()) {
            if (!module.getDataModuleName().equals("LocalCache")) {
                log.trace("Getting incremental for data module : {}", module.getDataModuleName());

                ArrayList<Map<String, Object>> incrementalArray = (ArrayList<Map<String, Object>>) module.getIncremental();
                ArrayList<Map<String, Object>> keyes = cloner.deepClone(incrementalArray);


                for(Map<String, Object> incrementalEntry : keyes)
                    incrementalEntry.keySet().retainAll(Arrays.asList("hash", "ip", "url"));


                for(int i = 0; i < keyes.size(); i++){


                    if (!keyes.get(i).isEmpty()){

                        Map.Entry<String, Object> entry = keyes.get(i).entrySet().iterator().next();

                        if(exists(incremental, having(on(Map.class).containsValue(entry.getValue())))){
                            Map<String, Object> selectedRecord = selectFirst(incremental, having(on(Map.class).containsValue(entry.getValue())));
                            selectedRecord.putAll(incrementalArray.get(i));
                        }else{
                            incremental.add(incrementalArray.get(i));
                        }
                    }

                }


            }
        }

        incrementalList.put(currentIncrement, cloner.deepClone(incremental));
        log.trace("Added new incremental with value {}.{} to list", currentRevision, currentIncrement);
        audit.info("Closed incremental {}", String.format("%d.%d", currentRevision, currentIncrement));

        lastIncremental = currentIncrement;
        lastRevision = currentRevision;

        currentIncrement++;

        if(!revisionStore.containsKey(currentRevision)){
            revisionStore.put(currentRevision, incrementalList);
        }

    }

    public static void closeRevision() {
        log.info("Closing revision : {}", currentRevision);
        revisionStore.put(currentRevision, (Map<Integer, ArrayList<Map<String, Object>>>) ((HashMap) incrementalList).clone());

        totalList = (ArrayList<Map<String, Object>>) cloner.deepClone(loadedModules.get("AeroSpike").getFullData());
        incrementalList.clear();
        incremental.clear();

        log.info("Added revision #{} to list", currentRevision);

        audit.info("Closed revision {}", currentRevision);

        if (revisionStore.size() > OFFSET) {
            revisionStore.remove(currentRevision - OFFSET);

            log.info("Removed revision #{} from list", currentRevision - OFFSET);
            audit.info("Removed revision #{} from list", currentRevision - OFFSET);
        }

        lastRevision = currentRevision;
        currentRevision++;
        currentIncrement = 0;


        for(Integer i : revisionStore.keySet()){
            log.info("Content for revision : " + i);

            String incremental = "";

            for(Integer j : revisionStore.get(i).keySet()){

                incremental.concat(" " + j);
            }

            log.info("Incrementals :{}", incremental);
        }

    }

    public static void start() {
        generatedIncrementalList.scheduleWithFixedDelay(new Generator(), MILLIS_INCREMENTAL, MILLIS_INCREMENTAL, TimeUnit.MILLISECONDS);
        log.info("Incremental list started!");
        audit.info("Incremental list is running!");

        Map<String, Object> json = new HashMap<>();
        json.put("current", String.format("%d.%d", currentRevision, currentIncrement));
        json.put("released", String.format("%d.%d", lastRevision, lastIncremental));
        json.put("count", COUNT % MATCHES);
        MalwareController.writeIncremental(json);

    }

    public static void stop() {

        if (currentIncrementalList != null)
            currentIncrementalList.cancel(true);

        audit.info("Incremental list is stopped");

    }

    public static void shutdown() {
        audit.info("Shutting down incremental list ... ");
        stop();
        generatedIncrementalList.shutdown();
    }

    public static void setRevision(int newRevision) {
        currentRevision = newRevision;
    }

    public static void setIncremental(int newRevision, int newIncremental, int count) {
        currentRevision = newRevision;
        log.trace("Set new revision : {}", currentRevision);
        currentIncrement = newIncremental;
        log.trace("Set new incremental : {}", currentIncrement);
        COUNT = count;
        log.trace("Remaining counts : {}", MATCHES - COUNT);

        lastRevision = newRevision;
    }

    public static void setLastIncremental(int newLastRevision, int newLastIncrement) {
        lastRevision = newLastRevision;
        lastIncremental = newLastIncrement;
    }

    public static void resetIncrementalList() {
        stop();
        revisionStore.clear();
        incremental.clear();
        incrementalList.clear();
        currentRevision = 1;
        currentIncrement = 0;
        COUNT = 0;
    }

    public static void check() {
        closeIncremental();
        COUNT++;

        log.trace("Remaining incrementals : {}", MATCHES - (COUNT % MATCHES));

        if (COUNT % MATCHES == 0) {
            closeRevision();
        }

        if (MalwareController.isCurrentLeader()) {
            Map<String, Object> json = new HashMap<>();
            json.put("current", String.format("%d.%d", currentRevision, currentIncrement));
            json.put("released", String.format("%d.%d", lastRevision, lastIncremental));
            json.put("count", COUNT % MATCHES);
            MalwareController.writeIncremental(json);
        } else {
            log.trace("Im not the leader!");
        }

    }

    public static ArrayList<Map<String, Object>> getTotalList()
    {
        return totalList;
    }

    private static class Generator implements Runnable {

        @Override
        public void run() {
            check();
        }
    }
}
