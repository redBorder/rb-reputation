package net.redborder.malware;

import net.redborder.malware.config.Config;
import net.redborder.malware.modules.data.DataModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.DataOutput;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class IncrementalList {

    public enum ValueOf{
        LAST_REVISION, LAST_INCREMENTAL
    }

    public enum List{
        INCREMENTAL, REVISION
    }

    private static Map<String, DataModule> loadedModules = null;

    // Logging
    private static final Logger log = LoggerFactory.getLogger(IncrementalList.class);

    // ArrayList with all JSONs
    private static ArrayList<Map<String, Object>> totalList = new ArrayList<>();

    // ArrayList with current incremental
    private static ArrayList<Map<String, Object>> incremental = new ArrayList<>();

    // Store of incrementals
    private static Map<String, ArrayList<Map<String, Object>>> incrementalList = new HashMap<>();

    // Store of revisions
    private static Map<String, Map<String, ArrayList<Map<String, Object>>>> revisionStore = new HashMap<>();

    // Current revision
    private static int revision = 0;

    // Current increment
    private static int increment = 0;

    // Number of enable revisions
    private static int OFFSET = 2;

    // Milliseconds to close incremental list
    private static long MILLIS_INCREMENTAL = TimeUnit.MINUTES.toMillis(15);

    // Milliseconds to close revision list
    private static long MILLIS_REVISION = TimeUnit.DAYS.toMillis(1);

    // Matches for close
    private static long MATCHES = 0;

    // Count of match
    private static long COUNT = 0;

    // Timer for generate incremental and revision
    private static ScheduledExecutorService generatedIncrementalList = Executors.newSingleThreadScheduledExecutor();
    private static ScheduledFuture currentIncrementalList;

    public static String getRevisionStore(){
        return revisionStore.keySet().toString();
    }

    public static String getValue(ValueOf value){

        switch(value){
            case LAST_REVISION:
                return String.valueOf(revision - 1);
            case LAST_INCREMENTAL:
                return String.format("%d.%d", revision - 1, increment - 1);
        }

        return null;
    }

    public static Object getCurrent(List list){
        switch(list) {
            case REVISION:
                return revisionStore;        // Current number of revision   [X]
            case INCREMENTAL:
                return incrementalList;       // Current number of incremental [Y]
        }

        return null;
    }

    public static void linkDataModules(Map<String, DataModule> modules){
        loadedModules = modules;
    }

    public static Object getList(String id){

        Pattern pattern = Pattern.compile("(?<revision>\\d+)(\\.?<incremental>\\d+)");

        Matcher matcher;

        String incremental;

        String revision;

        if((matcher = pattern.matcher(id)).matches()){

            incremental = matcher.group("incremental");
            revision = matcher.group("revision");

            if (incremental != null && !incremental.isEmpty()){
                return revisionStore.get(revision).get(incremental);
            }else if(revision != null && !revision.isEmpty()){
                return revisionStore.get(revision);
            }

        }

        return null;

    }

    public static void init(Config config){

        OFFSET = config.getInt("malware.revisionlist.offset", 2);

        MILLIS_INCREMENTAL = config.getTime("malware.incrementallist.incremental.time", "15M");
        System.out.println("Set incremental time to : " + MILLIS_INCREMENTAL);
        MILLIS_REVISION = config.getTime("malware.incrementallist.revision.time", "1D");
        System.out.println("Set revision time to : " + MILLIS_REVISION);

        resetIncrementalList();

        int result = Long.compare(MILLIS_REVISION, MILLIS_INCREMENTAL);

        if(result < 0){
            // Revision must be greater than incremental -> Exception
        }else{
            MATCHES = MILLIS_REVISION/MILLIS_INCREMENTAL;
        }

        revisionStore.put(String.format("%d", revision), incrementalList);
    }

    public static void closeIncremental(){

        for(DataModule module : loadedModules.values()){
            incremental.addAll((ArrayList<Map<String, Object>>) module.getIncremental());
        }

        incrementalList.put(String.format("%d.%d", revision, increment), (ArrayList<Map<String, Object>>) incremental.clone());
        incremental.clear();
        increment++;

    }

    public static void closeRevision(){
        revisionStore.put(String.format("%d", revision), (Map<String, ArrayList<Map<String, Object>>>) ((HashMap) incrementalList).clone());
        revision++;
        incrementalList.clear();
        increment = 1;
        revisionStore.put(String.format("%d", revision), incrementalList);

        if(revisionStore.size() > OFFSET)
            revisionStore.remove(String.format("%s", (revision - OFFSET)));

    }

    public static void start(){
        generatedIncrementalList.scheduleWithFixedDelay(new Generator(), 0L, MILLIS_INCREMENTAL, TimeUnit.MILLISECONDS);
    }

    public static void stop(){

        if(currentIncrementalList != null)
            currentIncrementalList.cancel(true);

    }

    public static void shutdown(){
        stop();
        generatedIncrementalList.shutdown();
    }

    public static void resetIncrementalList(){
        stop();
        revisionStore.clear();
        incremental.clear();
        incrementalList.clear();
        revision = 1;
        increment = 1;
        COUNT = 0;
    }

    private static class Generator implements Runnable {

        @Override
        public void run() {

            System.out.println("Closing incremental : " + increment);
            closeIncremental();
            COUNT++;

            if(COUNT % MATCHES == 0){
                System.out.println("Closing revision : " + revision);
                closeRevision();
            }
        }
    }


}
