package net.redborder.malware;

import net.redborder.malware.config.Config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class IncrementalList {

    // Logging
    private static final Logger log = LoggerFactory.getLogger(IncrementalList.class);

    // ArrayList with all JSONs
    private static ArrayList<Map<String, Object>> totalList = new ArrayList<>();

    // ArrayList with current incremental
    private static ArrayList<Map<String, Object>> incremental = new ArrayList<>();

    // Store of incrementals
    private static HashMap<String, ArrayList<Map<String, Object>>> incrementalList = new HashMap<>();

    // Store of revisions
    private static HashMap<String, Map<String, Object>> revisionStore = new HashMap<>();

    // Current revision
    private static int revision = 0;

    // Current increment
    private static int increment = 0;

    // Number of enable revisions
    private static int OFFSET = 2;

    // Milliseconds to close incremental list
    private static long MILLIS_INCREMENTAL = TimeUnit.MINUTES.toMillis(15);

    // Milliseconds to close revision list
    private static long MILLIS_REVISION = TimeUnit.DAYS.toMillis(1);

    // Timer for generate revision
    private static Timer generateRevision = new Timer();

    // Timer for generate incremental
    private static Timer generateIncremental = new Timer();

    public static String getRevisionStore(){
        return revisionStore.keySet().toString();
    }

    public static void init(Config config){
        OFFSET = config.getInt("malware.revisionlist.offset",2);
        MILLIS_INCREMENTAL = config.getLong("malware.incrementallist.revision.time", TimeUnit.MINUTES.toMillis(15));
        MILLIS_REVISION = config.getLong("malware.incrementallist.incremental.time", TimeUnit.DAYS.toMillis(1));

        totalList.clear();
        revisionStore.clear();
        incrementalList.clear();
    }

    public static void closeIncremental(){
        incrementalList.put(String.format("%d.%d",revision, increment), (ArrayList<Map<String, Object>>) incremental.clone());
        incremental.clear();
        increment++;
    }

    public static void closeRevision(){

        revisionStore.put(String.format("%d", revision), (Map<String, Object>) incrementalList.clone());
        incrementalList.clear();
        revision++;
        increment = 0;

        if(revisionStore.size() > OFFSET)
            revisionStore.remove(String.format("%s",(revision - OFFSET)));

    }

    public static void start(){
        generateRevision.scheduleAtFixedRate(new generateRevision(), 0L, MILLIS_REVISION);
        generateIncremental.scheduleAtFixedRate(new generateIncremental(), 0L, MILLIS_INCREMENTAL);
    }

    public static void shutdown(){
        generateIncremental.cancel();
        generateRevision.cancel();
    }

    private static class generateRevision extends TimerTask {

        @Override
        public void run() {
            closeRevision();
        }
    }


    private static class generateIncremental extends TimerTask {

        @Override
        public void run() {
            closeIncremental();
        }
    }


}
