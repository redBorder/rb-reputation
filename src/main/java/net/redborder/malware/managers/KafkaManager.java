package net.redborder.malware.managers;


import kafka.common.KafkaException;
import kafka.consumer.Consumer;
import kafka.consumer.ConsumerConfig;
import kafka.consumer.KafkaStream;
import kafka.javaapi.consumer.ConsumerConnector;
import kafka.javaapi.producer.Producer;
import kafka.producer.KeyedMessage;
import kafka.producer.ProducerConfig;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.tasks.executortask.ConsumeMessages;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class KafkaManager {

    final Logger log = LoggerFactory.getLogger(KafkaManager.class);

    private static Producer<String, String> producer;

    private static ProducerConfig producerConfig;

    private static Config config;

    private static ConsumerConnector consumer;

    private ExecutorService executor;

    public KafkaManager(Config conf) throws ConfigException {

        config = conf;

        init(config.getProperties());
    }

    private static void init(Properties props) throws ConfigException {

        producerConfig = new ProducerConfig(props);

        producer = new Producer<String, String>(producerConfig);

        consumer = Consumer.createJavaConsumerConnector(new ConsumerConfig(config.getProperties()));

    }

    public void consumeFromTopic(String topic, int threads) {

        Map<String, Integer> topicCountMap = new HashMap<String, Integer>();

        topicCountMap.put(topic, new Integer(threads));

        Map<String, List<KafkaStream<byte[], byte[]>>> consumerMap = consumer.createMessageStreams(topicCountMap);

        List<KafkaStream<byte[], byte[]>> streams = consumerMap.get(topic);

        executor = Executors.newFixedThreadPool(threads);

        int threadNumber = 0;

        for (final KafkaStream stream : streams) {
            executor.submit(new ConsumeMessages(stream));
            threadNumber++;
        }
    }

    public void sendMessage(String topic, String key, String message) {

        KeyedMessage<String, String> msg = new KeyedMessage<String, String>(topic, key, message);

        producer.send(msg);
    }

    public void sendMessage(String topic, String message) {

        KeyedMessage<String, String> msg = new KeyedMessage<String, String>(topic, String.valueOf(null), message);

        producer.send(msg);
    }

    public void closeProducer() {
        try {
            producer.close();
        } catch (KafkaException e) {
            e.printStackTrace();
        }
    }

}