package net.redborder.malware;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import net.redborder.malware.managers.AeroSpikeManager;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.KafkaManager;
import net.redborder.malware.tasks.executortask.ConsumeMessages;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.JsonGenerationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;

import static spark.Spark.get;

public class MalwareREST {

    private static Client RESTclient = null;
    
    private static final int ms = 7000;

    private static final String NAMESPACE = "malware";
    private static final String COLLECTION = "rb_malware";

    private static Config conf = null;

    private static AeroSpikeManager asm = null;

    private static KafkaManager km = null;

    private static final Logger log = LoggerFactory.getLogger(MalwareREST.class);

    private static CuratorFramework cf;

    private static ZkUtils zkUtils = null;

    private static QueryTimerTask qtt = null;

    private static int OFFSET = 2;

    private static ArrayList<Map<String, Object>> total = new ArrayList<>();

    private static Map<String, ArrayList<Map<String, Object>>> mapeoRevisiones = new HashMap<>();

    private static int revision = 0;

    private static Timer timer;

    public static void main(String[] args) throws JsonGenerationException {

        conf = new Config("/mwlist.properties");

        loadConfig();

        try {

            // Init AeroSpike Manager
            asm = new AeroSpikeManager(conf);

            // Verify connection with AeroSpike
            if (asm.verifyConnection()) {
                log.info("Connection stablished with AeroSpike");
            }

            // Init Kafka Manager
            km = new KafkaManager(conf);
            km.consumeFromTopic("rb_malware", 1);

            // Init curator RESTclient
            cf = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            cf.start();

            // Init ZkUtils
            zkUtils = new ZkUtils(cf, String.format("/%s", conf.get("malware.zkWorkspace")));

            // Register this node
            zkUtils.registerNode();

            System.out.println("Leader is selected? :  " + zkUtils.leaderIsSelected());

            while (!zkUtils.leaderIsSelected()) {
                Thread.sleep(ms);
            }

            zkUtils.createEphemeralNodeIfNotExist("leader");

            zkUtils.createEphemeralNodeIfNotExist("revision");

            if (zkUtils.isLeader()) {

                timer = new Timer();
                qtt = new QueryTimerTask();

                zkUtils.writeJsonInNode("revision", new HashMap<String, String>() {
                    {
                        put("revision", String.valueOf(revision));
                    }
                });

                zkUtils.writeJsonInNode("leader", new HashMap<String, String>() {
                    {
                        put("leader", InetAddress.getLocalHost().getHostName());
                    }
                });

                timer.schedule(qtt, 0, conf.getInt("malware.query.ms"));

            } else {

                revision = Integer.valueOf(zkUtils.readJsonFrom("/malware_list/revision").get("revision"));

                RESTclient = Client.create();

                WebResource webResource = RESTclient.resource(String.format("http://localhost:4567/malware_list/revision/%s",revision));
                ClientResponse response = webResource.accept("application/json").get(ClientResponse.class);

                if(response.getStatus() == 200){
                    String output = response.getEntity(String.class);
                }

                total = queryTotal();

                zkUtils.watcherChildren(new TaskLeaderWatcher(), "/malware_list/leader");
                zkUtils.watcherChildren(new TaskRevisionWatcher(), "/malware_list/revision");

            }


        } catch (ConfigException e) {
            e.printStackTrace();
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        get("/malware/total/", (req, res) -> getTotal(), new JsonTransformer());

        get("/malware/revision/", (req, res) -> revision);

        get("/malware/revision/:num", (req, res) -> getRevNum(Integer.valueOf(req.params(":num"))), new JsonTransformer());

        get("/malware/:sha", (req, res) -> {

            String sha256 = req.params(":sha");

            if (sha256.matches("[A-Fa-f0-9]{64}")) {

                Map<String, Object> result = asm.get(NAMESPACE, COLLECTION, sha256);

                Map<String, Object> mapJson = new HashMap<String, Object>();

                mapJson.put(sha256, result.get("malware_name"));

                return mapJson;

            } else {
                return "Your SHA256 is not complete, It must consist of 64 hexadecimal characters";
            }}
            , new JsonTransformer());


        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                log.info("Shutting down ...");

                if (zkUtils != null) {
                    zkUtils.unRegisterNode();
                    zkUtils.shutdown();
                }

                if(timer != null)
                    timer.cancel();

                log.info("Shutdown!");

            }
        });

    }

    private static void loadConfig(){
        try {
            OFFSET = conf.getInt("malware.query.offset");
        } catch (ConfigException e) {
            e.printStackTrace();
        }
    }

    private static ArrayList<Map<String, Object>> queryTotal() {

        ArrayList<Map<String, Object>> total = asm.getList("malware", "rb_malware");

        for (Map<String, Object> m : total) {
            m.remove("cuckoo_before");
            m.put("action", "create");
        }

        return total;
    }


    private static ArrayList<Map<String, Object>> getRevNum(int numRev) {
        String key = String.format("rev_%d", numRev);
        return mapeoRevisiones.containsKey(key) ? mapeoRevisiones.get(key) : null;
    }

    private static ArrayList<Map<String, Object>> getTotal() {
        return total;
    }

    private static void process(){

        System.out.println("Created/Update total");

        total = queryTotal();

        if (mapeoRevisiones.isEmpty()) {
            mapeoRevisiones.put(String.format("rev_%d", revision), ConsumeMessages.getRevision());
        } else {
            ConsumeMessages.newRevision();
            revision++;
            mapeoRevisiones.put(String.format("rev_%d", revision), ConsumeMessages.getRevision());
        }

        System.out.println("Created revision : " + revision);

        if (mapeoRevisiones.size() > OFFSET) {
            System.out.println("Deleted revision : " + (revision - OFFSET));
            mapeoRevisiones.remove(String.format("rev_%d", revision - OFFSET));
        }

    }

    public static class QueryTimerTask extends TimerTask {

        @Override
        public void run() {
            process();
        }

    }

    private static class TaskLeaderWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDataChanged:
                    break;

                case NodeDeleted:

                    break;
            }

        }
    }

    private static class TaskRevisionWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDataChanged:
                    MalwareREST.process();
                    break;

                case NodeDeleted:
                    break;
            }

        }
    }

}
