package net.redborder.malware;

import net.redborder.malware.managers.AeroSpikeManager;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.KafkaManager;
import net.redborder.malware.tasks.timertask.QueryTimerTask;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.curator.utils.ZKPaths;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.map.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static spark.Spark.get;

public class MalwareREST {

    private static final String NAMESPACE = "malware";

    private static final String COLLECTION = "rb_malware";

    private static AeroSpikeManager asm = null;
    private static KafkaManager km = null;

    private static final Logger log = LoggerFactory.getLogger(MalwareREST.class);

    private static ObjectMapper _mapper = new ObjectMapper();

    private static CuratorFramework cf;

    private static ZkUtils zkUtils = null;


    public static void main(String[] args) {

        Config conf = new Config("/mwlist.properties");

        Timer timer = new Timer();

        try {

            cf = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            cf.start();

            zkUtils = new ZkUtils(cf, String.format("/%s", conf.get("malware.zkWorkspace")));

            zkUtils.registerNode();
            zkUtils.createChildIfNotExist("leader");
            zkUtils.createChildIfNotExist("revision");

            asm = new AeroSpikeManager(conf);
            km = new KafkaManager(conf);
            km.consumeFromTopic("rb_malware", 1);

            if (asm.verifyConnection()) {
                log.info("Connection stablished");
            }

            ZKPaths.makePath(cf.getNamespace(),"/revision");

            QueryTimerTask.setClientAerospark(asm);
            QueryTimerTask.setOffset(conf.getInt("malware.query.offset"));

            timer.schedule(QueryTimerTask.getInstance(), 0, conf.getInt("malware.query.ms"));

        } catch (ConfigException e) {
            e.printStackTrace();
        }

        get("/malware/total/", (req, res) -> _mapper.writeValueAsString(QueryTimerTask.getTotal()));

        get("/malware/revision/", (req, res) -> QueryTimerTask.getCurrentRevision());

        get("/malware/revision/:num", (req, res) -> QueryTimerTask.getRevNum(Integer.valueOf(req.params(":num"))));

        get("/malware/:sha", (req, res) -> {

            String sha256 = req.params(":sha");

            if (sha256.matches("[A-Fa-f0-9]{64}")) {

                Map<String, Object> result = asm.get(NAMESPACE, COLLECTION, sha256);

                Map<String, Object> mapJson = new HashMap<String, Object>();

                mapJson.put(sha256, result.get("malware_name"));

                return _mapper.writeValueAsString(mapJson);

            } else
                return "Your SHA256 is not complete, It must consist of 64 hexadecimal characters";

        });

        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                log.info("Shutting down ...");

                if (zkUtils != null) {
                    zkUtils.unRegisterNode();
                    zkUtils.shutdown();
                }

                log.info("Shutdown!");

            }
        });

    }

    private class TaskWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch(type){

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDataChanged:
                    break;

                case NodeDeleted:
                    break;
            }

        }
    }

}
