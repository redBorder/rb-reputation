package net.redborder.malware;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import net.redborder.malware.managers.AeroSpikeManager;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.KafkaManager;
import net.redborder.malware.tasks.executortask.ConsumeMessages;
import net.redborder.malware.utils.JsonUtils;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.framework.recipes.cache.NodeCacheListener;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.JsonGenerationException;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.type.CollectionType;
import org.codehaus.jackson.type.TypeReference;
import org.jboss.netty.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spark.Request;
import spark.Response;
import spark.Route;

import static spark.Spark.*;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static spark.Spark.get;


public class MalwareREST {

    private static final Logger log = LoggerFactory.getLogger(MalwareREST.class);

    private long MS = 7000;
    private final String NAMESPACE = "malware";
    private final String COLLECTION = "rb_malware";
    private int OFFSET = 2;
    private String ipAddress = "0.0.0.0";
    private int port;

    private AeroSpikeManager asm;
    private KafkaManager km = null;

    private Config conf = null;

    private CuratorFramework cf;

    private ZkUtils zkUtils = null;

    private ArrayList<Map<String, Object>> total = new ArrayList<>();
    private Map<String, ArrayList<Map<String, Object>>> mapeoRevisiones = new HashMap<>();

    private int revision = 0;

    private Timer timer;

    private ObjectMapper mapper;

    public MalwareREST() {
        init();
    }

    public int getPort() {
        return port;
    }

    public String getAddress() {
        return ipAddress;
    }

    public int getRevision() {
        return revision;
    }

    private void init() {
        try {
            // Load configuration
            conf = new Config("/opt/rb/etc/rb-malware-list/mwlist.properties");
            loadConfig();

            // Init AeroSpike Manager
            asm = new AeroSpikeManager(conf);

            // Init Kafka Manager
            km = new KafkaManager(conf);

            // Init Curator client
            cf = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            cf.start();

            // Init ZkUtils
            zkUtils = new ZkUtils(cf, String.format("/%s", conf.get("malware.zkWorkspace")));
            // Register this node
            zkUtils.registerNode();

        } catch (ConfigException e) {
            e.printStackTrace();
        }
    }

    public void start() {
        discoverLeader();
    }

    private void discoverLeader() {

        while (!zkUtils.checkIfExist("/malware_list/leader")) {

            System.out.println("Checking if leader is selected...");

            // Am I the leader?
            if (zkUtils.isLeader()) { // Yes

                // Create node "leader"
                zkUtils.createEphemeralNodeIfNotExist("leader");
                // Create node "revision"
                zkUtils.createEphemeralNodeIfNotExist("revision");

                zkUtils.writeJsonInNode("revision", new HashMap<String, String>() {{
                    put("revision", String.valueOf(revision));
                }});

                zkUtils.writeJsonInNode("leader", new HashMap<String, String>() {{
                    try {
                        put("leader", InetAddress.getLocalHost().getCanonicalHostName());
                    } catch (UnknownHostException e) {
                        e.printStackTrace();
                    }
                }});

                timer = new Timer();
                QueryTimerTask qtt = new QueryTimerTask();
                timer.schedule(qtt, 0, MS);
            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        if (!zkUtils.isLeader()) {
            // Get revision
            revision = Integer.valueOf(zkUtils.readJsonFrom("/malware_list/revision").get("revision"));
            log.info("Set revision to {}", revision);
            System.out.println("Revision : " + revision);
            // Get total
            total = queryTotal();

            Client client = Client.create();

            ObjectMapper mapper = new ObjectMapper();

            String list = client.resource(String.format("http://%s:%d/malware/revision/%d", zkUtils.readJsonFrom("/malware_list/leader").get("leader"), port, revision)).accept("application/json").get(ClientResponse.class).getEntity(String.class);

            ArrayList<Map<String, Object>> currentRevision = null;

            try {
                currentRevision = mapper.readValue(list, new TypeReference<ArrayList<Map<String,Object>>>() {});
            } catch (IOException e) {
                e.printStackTrace();
            }

            mapeoRevisiones.put(String.format("rev_%d", revision), currentRevision);

            ConsumeMessages.setRevision(currentRevision);    // Aquí va la revisión

            // Put watcher on children node
            TaskLeaderWatcher taskLeader = new TaskLeaderWatcher();
            zkUtils.watcherChildren(taskLeader, "/malware_list/leader");
            log.info("Added watcher to /malware_list/leader");

            TaskRevisionWatcher taskRev = new TaskRevisionWatcher();
            zkUtils.watcherData(taskRev, "/malware_list/revision");
            log.info("Added watcher to /malware_list/revision");
        }

        km.consumeFromTopic("rb_malware", 1);

    }

    private void loadConfig() {
        try {
            OFFSET = conf.getInt("malware.query.offset");
            String[] host = conf.get("malware.server").split(":");
            ipAddress = host[0];
            port = Integer.valueOf(host[1]);
            MS = conf.getInt("malware.query.ms");
        } catch (ConfigException e) {
            e.printStackTrace();
        }

    }

    public void stop() {

        if (zkUtils != null) {
            zkUtils.unRegisterNode();
            zkUtils.shutdown();
        }

        if (timer != null)
            timer.cancel();


    }

    public static void main(String[] args) throws JsonGenerationException {


        final MalwareREST mREST = new MalwareREST();
        mREST.start();

        setIpAddress(mREST.ipAddress);
        setPort(mREST.port);


        get(new Route("/malware/total") {
            @Override
            public Object handle(Request request, Response response) {
                return mREST.getTotal();
            }
        });

        get(new Route("/malware/revision/") {
            @Override
            public Object handle(Request request, Response response) {
                return mREST.revision;
            }
        });

        get(new Route("/malware/revision/:num") {
            @Override
            public Object handle(Request request, Response response) {
                return mREST.getRevNum(Integer.valueOf(request.params(":num")));
            }
        });

        get(new Route("/malware/:sha") {

            @Override
            public Object handle(Request request, Response response) {
                String sha256 = request.params(":sha");

                if (sha256.matches("[A-Fa-f0-9]{64}")) {

                    Map<String, Object> result = mREST.asm.get(mREST.NAMESPACE, mREST.COLLECTION, sha256);

                    Map<String, Object> mapJson = new HashMap<String, Object>();

                    mapJson.put(sha256, result.get("malware_name"));

                    return mapJson;

                } else {
                    return "Your SHA256 is not complete, It must consist of 64 hexadecimal characters";
                }
            }


        });

        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {

                log.info("Shutting down ...");
                mREST.stop();
                log.info("Shutdown!");

            }
        });

    }


    private ArrayList<Map<String, Object>> queryTotal() {

        ArrayList<Map<String, Object>> total = asm.getList("malware", "rb_malware");

        for (Map<String, Object> m : total) {
            m.remove("cuckoo_before");
            m.put("action", "create");
        }

        return total;
    }

    private ArrayList<Map<String, Object>> getRevNum(int numRev) {
        String key = String.format("rev_%d", numRev);
        return mapeoRevisiones.containsKey(key) ? mapeoRevisiones.get(key) : null;
    }

    private ArrayList<Map<String, Object>> getTotal() {
        return total;
    }

    private void processRevision() {

        System.out.println("Created/Update total");

        total = queryTotal();

        if (mapeoRevisiones.isEmpty()) {
            mapeoRevisiones.put(String.format("rev_%d", revision), ConsumeMessages.getRevision());
        } else {
            ConsumeMessages.newRevision();
            System.out.println("Revision before : " + revision);
            revision++;
            System.out.println("Revision after : " + revision);
            mapeoRevisiones.put(String.format("rev_%d", revision), ConsumeMessages.getRevision());
        }

        System.out.println("Created revision : " + revision);

        if (mapeoRevisiones.size() > OFFSET) {
            System.out.println("Deleted revision : " + (revision - OFFSET));
            mapeoRevisiones.remove(String.format("rev_%d", revision - OFFSET));
        }

    }

    private class TaskLeaderWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    System.out.println("Leader was deleted!");
                    discoverLeader();
                    break;
            }

        }
    }

    private class TaskRevisionWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {
                case NodeDataChanged:
                    System.out.println("Data has changed!");
                    processRevision();
                    break;

                case NodeDeleted:
                    log.info("Node {} deleted!", watchedEvent.getPath());
                    break;
            }

        }
    }

    private class QueryTimerTask extends TimerTask {
        public void run() {
            processRevision();

            zkUtils.writeJsonInNode("revision", new HashMap<String, String>() {
                {
                    put("revision", String.valueOf(revision));
                }
            });
        }
    }
}
