package net.redborder.malware;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.WebResource;
import net.redborder.malware.managers.AeroSpikeManager;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.managers.KafkaManager;
import net.redborder.malware.tasks.executortask.ConsumeMessages;
import net.redborder.malware.utils.ZkUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorWatcher;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.codehaus.jackson.JsonGenerationException;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spark.Request;
import spark.Response;
import spark.Route;

import static spark.Spark.*;

import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.*;

import static spark.Spark.get;


public class MalwareREST {

    private static Client RESTclient = null;
    
    private static final int ms = 7000;

    private static final String NAMESPACE = "malware";
    private static final String COLLECTION = "rb_malware";

    private static Config conf = null;

    private static AeroSpikeManager asm = null;

    private static KafkaManager km = null;

    private static final Logger log = LoggerFactory.getLogger(MalwareREST.class);

    private static CuratorFramework cf;

    private static ZkUtils zkUtils = null;

    private static QueryTimerTask qtt = null;

    private static int OFFSET = 2;

    private static ArrayList<Map<String, Object>> total = new ArrayList<>();

    private static Map<String, ArrayList<Map<String, Object>>> mapeoRevisiones = new HashMap<>();

    private static int revision = 0;

    private static Timer timer;

    private static String port;

    private static ObjectMapper mapper;

    public static void main(String[] args) throws JsonGenerationException {

        conf = new Config("/opt/rb/etc/rb-malware-list/mwlist.properties");


        try {

            loadConfig();
            setIpAddress(conf.get("malware.server").split(":")[0]);
            setPort(Integer.valueOf(port));

            // Init AeroSpike Manager
            asm = new AeroSpikeManager(conf);

            // Verify connection with AeroSpike
            if (asm.verifyConnection()) {
                log.info("Connection stablished with AeroSpike");
            }

            // Init Kafka Manager
            km = new KafkaManager(conf);
            km.consumeFromTopic("rb_malware", 1);

            // Init curator
            cf = CuratorFrameworkFactory.newClient(conf.get("zookeeper.connect"), new RetryNTimes(Integer.MAX_VALUE, 30000));
            cf.start();

            // Init ZkUtils
            zkUtils = new ZkUtils(cf, String.format("/%s", conf.get("malware.zkWorkspace")));

            // Register this node
            zkUtils.registerNode();

            System.out.println("Leader is selected? :  " + zkUtils.leaderIsSelected());

            while (!zkUtils.leaderIsSelected()) {
                Thread.sleep(ms);
            }

            if (zkUtils.isLeader()) {

                zkUtils.createEphemeralNodeIfNotExist("leader");
                zkUtils.createEphemeralNodeIfNotExist("revision");

                timer = new Timer();
                qtt = new QueryTimerTask();

                zkUtils.writeJsonInNode("revision", new HashMap<String, String>() {
                    {
                        put("revision", String.valueOf(revision));
                    }
                });

                zkUtils.writeJsonInNode("leader", new HashMap<String, String>() {
                    {
                        put("leader", InetAddress.getLocalHost().getHostAddress());
                    }
                });

                timer.schedule(qtt, 0, conf.getInt("malware.query.ms"));

            } else {

                mapper = new ObjectMapper();
                revision = Integer.valueOf(zkUtils.readJsonFrom("/malware_list/revision").get("revision"));

                total = queryTotal();

                zkUtils.watcherChildren(new TaskLeaderWatcher(), "/malware_list/leader");
                log.info("Added watcher to /malware_list/leader");
                zkUtils.watcherChildren(new TaskRevisionWatcher(), "/malware_list/revision");
                log.info("Added watcher to /malware_list/revision");

            }


        } catch (ConfigException e) {
            e.printStackTrace();
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        get(new Route("/malware/total") {
            @Override
            public Object handle(Request request, Response response) {
                return getTotal();
            }
        });

        get(new Route("/malware/revision/") {
            @Override
            public Object handle(Request request, Response response) {
                return revision;
            }
        });

        get(new Route("/malware/revision/:num") {
            @Override
            public Object handle(Request request, Response response) {
                return getRevNum(Integer.valueOf(request.params(":num")));
            }
        });

        get(new Route("/malware/:sha") {

            @Override
            public Object handle(Request request, Response response) {
                String sha256 = request.params(":sha");

                if (sha256.matches("[A-Fa-f0-9]{64}")) {

                    Map<String, Object> result = asm.get(NAMESPACE, COLLECTION, sha256);

                    Map<String, Object> mapJson = new HashMap<String, Object>();

                    mapJson.put(sha256, result.get("malware_name"));

                    return mapJson;

                } else {
                    return "Your SHA256 is not complete, It must consist of 64 hexadecimal characters";
                }}


        });


        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                log.info("Shutting down ...");

                if (zkUtils != null) {
                    zkUtils.unRegisterNode();
                    zkUtils.shutdown();
                }

                if(timer != null)
                    timer.cancel();

                log.info("Shutdown!");

            }
        });

    }


    private static void loadConfig(){
        try {
            OFFSET = conf.getInt("malware.query.offset");
            port = conf.get("malware.server").split(":")[1];
        } catch (ConfigException e) {
            e.printStackTrace();
        }
    }

    private static ArrayList<Map<String, Object>> queryTotal() {

        ArrayList<Map<String, Object>> total = asm.getList("malware", "rb_malware");

        for (Map<String, Object> m : total) {
            m.remove("cuckoo_before");
            m.put("action", "create");
        }

        return total;
    }


    private static ArrayList<Map<String, Object>> getRevNum(int numRev) {
        String key = String.format("rev_%d", numRev);
        return mapeoRevisiones.containsKey(key) ? mapeoRevisiones.get(key) : null;
    }

    private static ArrayList<Map<String, Object>> getTotal() {
        return total;
    }

    private static void process(){

        System.out.println("Created/Update total");

        total = queryTotal();

        if (mapeoRevisiones.isEmpty()) {
            mapeoRevisiones.put(String.format("rev_%d", revision), ConsumeMessages.getRevision());
        } else {

            ConsumeMessages.newRevision();

            revision++;

            zkUtils.writeJsonInNode("revision", new HashMap<String, String>() {
                {
                    put("revision", String.valueOf(revision));
                }
            });

            mapeoRevisiones.put(String.format("rev_%d", revision), ConsumeMessages.getRevision());
        }

        System.out.println("Created revision : " + revision);

        if (mapeoRevisiones.size() > OFFSET) {
            System.out.println("Deleted revision : " + (revision - OFFSET));
            mapeoRevisiones.remove(String.format("rev_%d", revision - OFFSET));
        }

    }

    public static class QueryTimerTask extends TimerTask {

        @Override
        public void run() {
            process();
        }

    }

    private static class TaskLeaderWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDataChanged:
                    break;

                case NodeDeleted:

                    Thread leaderDiscover = new Thread(){
                            public void run(){
                                while(zkUtils.readJsonFromNode("leader").isEmpty()){
                                    try {
                                        Thread.sleep(2000);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                }
                            }
                    };

                    leaderDiscover.start();



                    break;
            }

        }
    }

    private static class TaskRevisionWatcher implements CuratorWatcher {

        @Override
        public void process(WatchedEvent watchedEvent) throws Exception {

            Watcher.Event.EventType type = watchedEvent.getType();

            log.info("Watching call, {}", type.name());

            switch (type) {

                case NodeChildrenChanged:
                    break;

                case NodeCreated:
                    break;

                case NodeDataChanged:
                    MalwareREST.process();
                    break;

                case NodeDeleted:
                    break;
            }

        }
    }

}
