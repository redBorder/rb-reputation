package net.redborder.malware.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Config{

    final Logger log = LoggerFactory.getLogger(Config.class);

    // Properties of configuration
    private static Properties createdConfigure = new Properties();

    // Properties of configuration
    private Properties config;

    // Configuration file by default
    private String FILE_CONF = "config.properties";

    // Constructor without config file
    public Config(){
        reload();
    }

    // Constructor with config file
    public Config(String path){
        FILE_CONF = path;
        reload();
    }

    // Constructor with properties object
    public Config(Properties prop){
        config = prop;
    }

    /**
     * Allow reload configuration file
     */
    public void reload(){
        // Create new properties object
        config = new Properties();

        try {
            // Load properties from configuration file
            config.load(new InputStreamReader(new FileInputStream(FILE_CONF)));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Get a property value as String
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return String or default value if property not exists
     */
    public String get(String property, String defaultValue) {
        return !config.containsKey(property) ? defaultValue : String.valueOf(config.get(property));
    }

    /**
     * Allow put a property with String value
     * @param property Name of property
     * @param value Value of property
     */
    public static void add(String property, String value){
        createdConfigure.setProperty(property, value);
    }


    /**
     * Get a property value as String
     * @param property Name of property
     * @return Value of property as String
     * @throws ConfigException if property not exists
     */
    public String get(String property) throws ConfigException {
        if(config.containsKey(property)) {
            return String.valueOf(config.get(property));
        } else {
            throw new ConfigException("Missing key " + property + ".");
        }
    }

    public long getTime(String k, String time){

        if(config.containsKey(k)){
            return  parseTime(config.get(k).toString());
        }

        return parseTime(time);
    }

    public long getTime(String k){
            return  parseTime(config.get(k).toString());
    }

    public static void addTime(String k, String time){
        createdConfigure.put(k, time);
    }

    /**
     * Get property value as List of Strings
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return List of Strings or default value if property not exists
     */
    public List<String> getList(String property, List<String> defaultValue){

        if(!config.containsKey(property)){
            return defaultValue;
        }else{
            String value = String.valueOf(config.get(property));
            String [] pieces = value.split("\\s*,\\s*");

            for(int i = 0 ; i < pieces.length; i++)
                pieces[i] = pieces[i].trim();

            return Arrays.asList(pieces);
        }
    }

    /**
     * Get property value as List of Strings
     * @param property Name of property
     * @return Value of property as List of Strings
     * @throws ConfigException If property not exists
     */
    public List<String> getList(String property) throws ConfigException {
        if(!config.containsKey(property)) {
            throw new ConfigException("Missing key " + property + ".");
        } else {
            return this.getList(property, (List) null);
        }
    }

    public static void addList(String k, String list){
        createdConfigure.setProperty(k, list);
    }


    /**
     * Get property value as Boolean
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return Boolean or default value if property not exists
     */
    public boolean getBoolean(String property, boolean defaultValue) {
        return config.containsKey(property) ? "true".equalsIgnoreCase(String.valueOf(config.get(property))) : defaultValue;
    }

    /**
     * Clear defined properties
     */
    public static void clearConfiguration(){
        createdConfigure.clear();
    }

    public static void addBoolean(String k, boolean value){
        createdConfigure.setProperty(k, String.valueOf(value));
    }

    /**
     * Get property value as Boolean
     * @param property Name of property
     * @return Value of property as Boolean
     * @throws ConfigException If property not exists
     */
    public boolean getBoolean(String property) throws ConfigException {
        if(config.containsKey(property)) {
            return "true".equalsIgnoreCase(String.valueOf(config.get(property)));
        } else {
            throw new ConfigException("Missing key " + property + ".");
        }
    }

    public static void addShort(String k, short value){
        createdConfigure.setProperty(k, String.valueOf(value));
    }

    /**
     * Get property value as Short
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return Short or default value if property not exists
     */
    public short getShort(String property, short defaultValue) {
        return config.containsKey(property) ? Short.parseShort(String.valueOf(config.get(property))) : defaultValue;
    }

    /**
     * Get property value as Short
     * @param property Name of property
     * @return Value of property as Short
     * @throws ConfigException If property not exists
     */
    public short getShort(String property) throws ConfigException {
        if(config.containsKey(property)) {
            return Short.parseShort(String.valueOf(config.get(property)));
        } else {
            throw new ConfigException("Missing key " + property + ".");
        }
    }

    public static void addLong(String k, long value){
        createdConfigure.setProperty(k, String.valueOf(value));
    }

    /**
     * Get property value as Long
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return Long or default value if property not exists
     */
    public long getLong(String property, long defaultValue) {
        return config.containsKey(property) ? Long.parseLong(String.valueOf(config.get(property))) : defaultValue;
    }

    /**
     * Get property value as Long
     * @param property Name of property
     * @return Value of property as Long
     * @throws ConfigException If property not exists
     */
    public long getLong(String property) throws ConfigException {
        if(config.containsKey(property)) {
            return Long.parseLong(String.valueOf(config.get(property)));
        } else {
            throw new ConfigException("Missing key " + property + ".");
        }
    }

    public static void addInt(String k, int value){
        createdConfigure.setProperty(k, String.valueOf(value));
    }

    /**
     * Get property value as Integer
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return Integer or default value if property not exists
     */
    public int getInt(String property, int defaultValue) {
        return config.containsKey(property) ? Integer.parseInt(String.valueOf(config.get(property))) : defaultValue;
    }

    /**
     * Get property value as Integer
     * @param property Name of property
     * @return Value of property as Integer
     * @throws ConfigException If property not exists
     */
    public int getInt(String property) throws ConfigException {
        if(config.containsKey(property)) {
            return Integer.parseInt(String.valueOf(config.get(property)));
        } else {
            throw new ConfigException("Missing key " + property + ".");
        }
    }

    public static void addDouble(String k, double value){
        createdConfigure.setProperty(k, String.valueOf(value));
    }

    /**
     * Get property value as Double
     * @param property Name of property
     * @param defaultValue Value by default if property not exists
     * @return Double or default value if property not exists
     */
    public double getDouble(String property, double defaultValue) {
        return config.containsKey(property) ? Double.parseDouble(String.valueOf(config.get(property))) : defaultValue;
    }

    /**
     * Get property value as Double
     * @param property Name of property
     * @return Value of property as Double
     * @throws ConfigException If property not exists
     */
    public double getDouble(String property) throws ConfigException {
        if(config.containsKey(property)) {
            return Double.parseDouble(String.valueOf(config.get(property)));
        } else {
            throw new ConfigException("Missing key " + property + ".");
        }
    }

    public static void addClass(String k, String value){
        createdConfigure.setProperty(k, value);
    }

    public <T> Class<?> getClass(String k) throws ConfigException {
        if(config.containsKey(k)) {
            try {
                return Class.forName(String.valueOf(config.get(k)));
            } catch (Exception var3) {
                throw new ConfigException("Unable to find class.");
            }
        } else {
            throw new ConfigException("Missing key " + k + ".");
        }
    }

    public <T> Object getNewInstance(String k) throws ConfigException {

        if(config.containsKey(k)){

            try {
                return Class.forName(String.valueOf(config.get(k))).getDeclaredConstructor().newInstance();
            } catch (Exception var3) {
                throw new ConfigException("Unable to find class.");
            }

        }else{
            throw new ConfigException("Unable to instantiate class.");
        }

    }

    public static void addDate(String k, Date value){
        createdConfigure.setProperty(k, value.toString());
    }

    public Date getDate(String k) throws ConfigException {
        return this.getDate(k, new SimpleDateFormat());
    }

    public Date getDate(String k, String format) throws ConfigException {
        return this.getDate(k, new SimpleDateFormat(format));
    }

    public Date getDate(String k, SimpleDateFormat format) throws ConfigException {
        if(!config.contains(k)) {
            throw new ConfigException("Missing key " + k + ".");
        } else {
            try {
                return format.parse((String)this.get(k));
            } catch (ParseException var4) {
                throw new ConfigException("Date format exception.");
            }
        }
    }

    public Date getDate(String k, Date defaultValue) throws ConfigException {
        return this.getDate(k, new SimpleDateFormat(), defaultValue);
    }

    public Date getDate(String k, String format, Date defaultValue) throws ConfigException {
        return this.getDate(k, new SimpleDateFormat(format), defaultValue);
    }

    public Date getDate(String k, SimpleDateFormat format, Date defaultValue) throws ConfigException {
        if(!config.containsKey(k)) {
            return defaultValue;
        } else {
            try {
                return format.parse((String)this.get(k));
            } catch (ParseException var5) {
                throw new ConfigException("Date format exception.");
            }
        }
    }

    public static Config createConfig(){
        return new Config(createdConfigure);
    }

    public Properties getProperties(){
        return config;
    }

    public long parseTime(String value){

        long time = 0;

        Pattern pattern = Pattern.compile("(?<units>\\d+)(?<time>D|H|M|S)");
        Matcher matcher = pattern.matcher(value);

        if( matcher != null && matcher.matches()){
            log.trace("Value matches!");
            log.debug("Value : {}", value);
            TimeUnit[] values = TimeUnit.values();

            for(TimeUnit tu : values)
                if(tu.toString().startsWith(matcher.group("time")) && !tu.toString().matches("(?:MICROSECONDS|MILLISECONDS)")) {

                    time = tu.toMillis(Long.valueOf(matcher.group("units")));
                    break;
                }
        }

        return time;
    }

}
