package net.redborder.malware;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class MalwareRevisionList {

    private static final Logger log = LoggerFactory.getLogger(MalwareRevisionList.class);

    // Queue for data
    private LinkedBlockingQueue<Map<String, Object>> queue;
    // ArrayList with all JSONs
    private ArrayList<Map<String, Object>> totalList = null;
    // ArrayList with current JSONs
    private ArrayList<Map<String, Object>> revisionList = null;
    // Map of revisions
    private Map<String, ArrayList<Map<String, Object>>> mapeoRevisiones = new HashMap<>();
    // Executor Service for threads
    private ExecutorService executorService;

    // Current revision
    private int revision = 0;
    // Number of enable revisions
    private int OFFSET = 2;

    // Get revision number
    public int getRevisionNumber() {
        return revision;
    }

    // We need config and AeroSpikeManager
    public MalwareRevisionList(int offset, LinkedBlockingQueue<Map<String, Object>> queue) {
        OFFSET = offset;
        this.queue = queue;
    }

    public void startContinuousQuery() {
        if (executorService == null)
            executorService = Executors.newSingleThreadExecutor();

        executorService.submit(new ReadFromQueue());
    }

    public void stopContinuousQuery() {
        executorService.shutdown();
    }

    public void finishCurrentRevision() {

        if (mapeoRevisiones.isEmpty()) {
            // Put the current revision
            mapeoRevisiones.put(String.format("revision%d", revision), revisionList);
        } else {
            createNewRevision();
            revision++;
            mapeoRevisiones.put(String.format("revision%d", revision), revisionList);
        }

        if (mapeoRevisiones.size() > OFFSET) {
            log.info("Deleted revision : {}", (revision - OFFSET));
            mapeoRevisiones.remove(String.format("revision%d", revision - OFFSET));
        }

    }

    public void createTotal(ArrayList<Map<String, Object>> total) {
        this.totalList = total;
    }

    public ArrayList<Map<String, Object>> getTotal() {
        if (totalList == null)
            totalList = new ArrayList<>();

        return totalList;
    }

    public ArrayList<Map<String, Object>> getRevNum(int numRev) {
        String key = String.format("revision%d", numRev);
        return mapeoRevisiones.containsKey(key) ? mapeoRevisiones.get(key) : null;
    }

    public ArrayList<Map<String, Object>> getCurrentRevision() {

        if (revisionList == null)
            revisionList = new ArrayList<>();

        return revisionList;
    }

    public void createNewRevision(ArrayList<Map<String, Object>> newRevision, int revisionNumber) {
        revision = revisionNumber;
        revisionList = newRevision;

        mapeoRevisiones.put(String.format("revision%d", revisionNumber), newRevision);
    }

    public void createNewRevision() {
        revisionList = new ArrayList<Map<String, Object>>();
        log.info("Created new revision : Revision {}", revision);
    }

    private class ReadFromQueue implements Runnable {

        @Override
        public void run() {
            try {
                revisionList.add(queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}
