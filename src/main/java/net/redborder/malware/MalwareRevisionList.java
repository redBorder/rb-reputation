package net.redborder.malware;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class MalwareRevisionList {

    private static final Logger log = LoggerFactory.getLogger(MalwareRevisionList.class);

    // Queue for data
    private LinkedBlockingQueue<Map<String, Object>> queue;
    // ArrayList with all JSONs
    private ArrayList<Map<String, Object>> totalList = null;
    // ArrayList with current JSONs
    private ArrayList<Map<String, Object>> revisionList = null;
    // Map of revisions
    private Map<String, ArrayList<Map<String, Object>>> mapeoRevisiones = new HashMap<>();
    // Executor Service for threads
    private ExecutorService executorService;

    // Current revision
    private int revision = 0;
    // Number of enable revisions
    private int OFFSET = 2;

    // Get revision number
    public int getRevisionNumber() {
        return revision;
    }

    // We need OFFSET and queue
    public MalwareRevisionList(int offset, LinkedBlockingQueue<Map<String, Object>> queue) {
        // Set OFFSET
        OFFSET = offset;
        // Set queue
        this.queue = queue;

        // Create new revisionList and register
        revisionList = new ArrayList<>();
        registerOnMap(revisionList);

        // Create new totalList
        totalList = new ArrayList<>();

    }

    public void startContinuousQuery() {
        if (executorService == null)
            executorService = Executors.newSingleThreadExecutor();

        executorService.submit(new ReadFromQueue());
    }

    public void stopContinuousQuery() {
        executorService.shutdown();
    }

    public void registerOnMap(ArrayList<Map<String, Object>> list){

        mapeoRevisiones.put(String.format("revision%d", revision), list);

        if (mapeoRevisiones.size() > OFFSET) {
            log.info("Deleted revision : {}", (revision - OFFSET));
            mapeoRevisiones.remove(String.format("revision%d", revision - OFFSET));
        }
    }

    public void finishCurrentRevision() {
            createNewRevision();
            revision++;
            registerOnMap(revisionList);
            log.info("Created new revision : Revision {}", revision);
    }

    public void createTotal(){
        this.totalList = new ArrayList<>();
    }

    public void createTotal(ArrayList<Map<String, Object>> total) {
        this.totalList = total;
    }

    public ArrayList<Map<String, Object>> getTotal() {
        if (totalList == null)
            totalList = new ArrayList<>();

        return totalList;
    }

    public ArrayList<Map<String, Object>> getRevNum(int numRev) {
        String key = String.format("revision%d", numRev);
        return mapeoRevisiones.containsKey(key) ? mapeoRevisiones.get(key) : null;
    }

    public ArrayList<Map<String, Object>> getCurrentRevision() {

        if (revisionList == null)
            revisionList = new ArrayList<>();

        return revisionList;
    }

    public void createAndRegisterNewRevision(ArrayList<Map<String, Object>> newRevision, int revisionNumber) {
        revision = revisionNumber;
        revisionList = newRevision;

        registerOnMap(revisionList);
    }

    public void createNewRevision() {
        revisionList = new ArrayList<Map<String, Object>>();
    }

    private class ReadFromQueue implements Runnable {

        @Override
        public void run() {
            try {
                revisionList.add(queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}
