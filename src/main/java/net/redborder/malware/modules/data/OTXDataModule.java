package net.redborder.malware.modules.data;

import com.aerospike.client.Bin;
import com.aerospike.client.Host;
import com.aerospike.client.Key;
import com.aerospike.client.Record;
import com.aerospike.client.async.AsyncClient;
import com.aerospike.client.async.AsyncClientPolicy;
import com.aerospike.client.policy.Policy;
import com.aerospike.client.policy.RecordExistsAction;
import com.aerospike.client.policy.WritePolicy;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import org.ho.yaml.Yaml;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class OTXDataModule {

    private static final Logger log = LoggerFactory.getLogger(OTXDataModule.class);

    private enum Status {
        INITIALIZATION, OUTDATED, UPDATED
    }

    public final String URL = "https://reputation.alienvault.com/";
    public final String CURRENT_REVISION = "reputation.rev";
    public final String ALL_DATA = "reputation.data";
    public final String ONE_REVISION = "revisions/reputation.data_";

    private String collection;
    private String namespace;
    private List<String> hosts;
    private int timeout;
    private WritePolicy writePolicy;
    private Map<String, Object> proxy;
    private AsyncClient aerospikeClient;

    // Timer for generate incremental and currentRevision
    private ScheduledExecutorService toWork = Executors.newSingleThreadScheduledExecutor();
    // Future of incremental list (Runnable)
    private ScheduledFuture currentWork;

    private long interval;

    private Status status;

    private Map<String, Object> weights;

    private Config config;

    private long currentRevision = -1L;

    public OTXDataModule(Config conf) {

        try {
            config = new Config("/etc/rb-reputation/config.properties");

            this.hosts = config.getList("otx.aerospike.servers");
            this.timeout = config.getInt("otx.aerospike.clientTimeout", 500);
            this.collection = config.get("otx.aerospike.collection", "ipScores");
            this.namespace = config.get("otx.aerospike.namespace", "malware");

            this.writePolicy = new WritePolicy();
            this.writePolicy.recordExistsAction = RecordExistsAction.UPDATE;

            status = Status.INITIALIZATION;

            weights = (Map<String, Object>) Yaml.load(new InputStreamReader(new FileInputStream("/etc/rb-reputation/weights.yml")));

        } catch (ConfigException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    public void init() {

        log.info("Initializing OTX Data Module");

        List<Host> servers = new ArrayList<>();
        proxy = new HashMap<>();

        for (String host : hosts) {
            String[] sp = host.split(":");
            servers.add(new Host(sp[0], Integer.valueOf(sp[1])));
        }

        AsyncClientPolicy cPolicy = new AsyncClientPolicy();
        cPolicy.timeout = timeout;

        aerospikeClient = new AsyncClient(cPolicy, servers.toArray(new Host[servers.size()]));
        log.trace(String.format("AeroSpike connected to %s", servers));

        reload();

        toWork.scheduleAtFixedRate(new OTXEngine(), 0, interval, TimeUnit.MILLISECONDS);

    }

    public void stop(){
        toWork.shutdown();
    }

    public void shutdownImpl() {
        log.info("Shutting down OTX data module ...");
        if (aerospikeClient.isConnected())
            aerospikeClient.close();
        log.info("Done!");
    }

    public void reload(){
        // Default 5 seconds
        this.interval = config.getTime("otx.interval", "15M");

        try {

            if (config.getProperties().contains("malware.proxy")) {
                String[] proxy = config.get("malware.proxy").split(":");
                this.proxy.put("ip", proxy[0]);
                this.proxy.put("port", Integer.parseInt(proxy[1]));
            } else {
                this.proxy = new HashMap<>();
            }
        } catch (ConfigException e) {
            e.printStackTrace();
        }
    }

    private class OTXEngine implements Runnable {

        @Override
        public void run() {

            Map<String, Object> specificWeights = (Map<String, Object>) weights.get("ip");

            HttpURLConnection conn;
            Proxy prox = null;
            URL objLookup;
            BufferedReader bufferedReader;
            String inputLine;
            int responseCode;


            if (!proxy.isEmpty()) {
                log.info("Using proxy in OTXDataModule");
                prox = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(String.valueOf(proxy.get("ip")), (Integer) proxy.get("port")));
            }

            try {
                if (status == Status.INITIALIZATION) {
                    objLookup = new URL(String.format("%s/%s", URL, ALL_DATA));

                    if (prox == null)
                        conn = (HttpURLConnection) objLookup.openConnection();
                    else
                        conn = (HttpURLConnection) objLookup.openConnection(prox);

                    conn.setRequestMethod("GET");
                    responseCode = conn.getResponseCode();

                    if (responseCode == 200) {
                        log.trace("Getting full data");
                        bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));

                        Pattern pattern = Pattern.compile("(?<ip>\\d{1,3}(?:.\\d{1,3}){3})#(?<s1>\\d+)#(?<s2>\\d+)#(?<category>\\w+(?:\\s+\\w+)?)#(?:.+)#(?:.+)#(?:.+)#(?:\\d+)");

                        while ((inputLine = bufferedReader.readLine()) != null) {
                            Matcher match = pattern.matcher(inputLine);

                            if (match.matches()) {

                                Map<String, Object> ipScores = new HashMap<>();

                                String ip = match.group("ip");
                                int calculatedScore = Integer.valueOf(match.group("s1")) * Integer.valueOf(match.group("s2")) * 2;
                                Long maxScore = Long.MIN_VALUE;

                                Key key = new Key(namespace, collection, ip);

                                Record record = aerospikeClient.get(new Policy(), key);

                                Long sectionScore = -1L;
                                Long globalScore = -1L;

                                if (record != null) {
                                    ipScores.putAll(record.bins);
                                    ipScores.put("rt_otx", calculatedScore);
                                } else {
                                    ipScores.put("ip", ip);
                                    ipScores.put("rt_otx", calculatedScore);
                                    ipScores.put("category", match.group("category"));
                                }


                                for (Map.Entry<String, Object> field : ipScores.entrySet())
                                    if (field.getKey().matches("rt_\\w+")) {
                                        Double score = Double.valueOf(field.getValue().toString());
                                        Double weight = Double.valueOf(specificWeights.containsKey(field.getKey()) ? specificWeights.get(field.getKey()).toString() : "0.0");

                                        if (score > 0) {
                                            if (sectionScore < 0) sectionScore = 0L;
                                            sectionScore += Double.valueOf(score * weight).longValue();
                                        }

                                        if (score > maxScore)
                                            maxScore = score.longValue();
                                    }


                                ipScores.put("g_rt_score", sectionScore);

                                for (Map.Entry<String, Object> field : ipScores.entrySet()) {
                                    if (field.getKey().matches("g_\\w+") && field.getKey().contains("score")) {
                                        Double localScore = Double.valueOf(field.getValue().toString());
                                        Double weight = Double.valueOf(specificWeights.containsKey(field.getKey()) ? specificWeights.get(field.getKey()).toString() : "0.0");

                                        if (localScore >= 0) {
                                            if (globalScore < 0) globalScore = 0L;
                                            globalScore += Double.valueOf(localScore * weight).longValue();
                                        }
                                    }
                                }

                                ipScores.put("score", globalScore);

                                if (calculatedScore > maxScore)
                                    ipScores.put("category", match.group("category"));

                                for (Map.Entry<String, Object> bins : ipScores.entrySet()) {
                                    aerospikeClient.put(writePolicy, key, new Bin(bins.getKey(), bins.getValue()));
                                }


                            }

                        }

                        bufferedReader.close();
                        conn.getInputStream().close();

                        log.trace("Full data completed!");
                    } // Full data


                    status = Status.OUTDATED;
                    log.trace("Current status : OUTDATED");

                }

/*
*  REVISION ----------------------------
* */

                objLookup = new URL(String.format("%s/%s", URL, CURRENT_REVISION));

                if (prox == null)
                    conn = (HttpURLConnection) objLookup.openConnection();
                else
                    conn = (HttpURLConnection) objLookup.openConnection(prox);

                conn.setRequestMethod("GET");
                responseCode = conn.getResponseCode();

                if(responseCode == 200){


                    bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));

                    while((inputLine = bufferedReader.readLine()) != null){


                        long revision = Long.valueOf(inputLine);

                        if(currentRevision < revision){
                            log.info("Getting revision");
                            currentRevision = revision;
                            status = Status.OUTDATED;
                            log.info("Current revision is : {}", currentRevision);
                            log.info("Current status : OUTDATED");
                        }
                    }


                    bufferedReader.close();
                    conn.getInputStream().close();
                }

/*
*  UPDATE WITH REVISION ----------------------------
* */

                if(status == Status.OUTDATED){
                    //UPDATE HERE WITH NEW REVISIONS!!!

                    objLookup = new URL(String.format("%s/%s%d", URL, ONE_REVISION, (currentRevision - 1)));

                    if (prox == null)
                        conn = (HttpURLConnection) objLookup.openConnection();
                    else
                        conn = (HttpURLConnection) objLookup.openConnection(prox);

                    conn.setRequestMethod("GET");
                    responseCode = conn.getResponseCode();

                    if(responseCode == 200){
                        log.trace("Getting last revision");
                        bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));

                        Pattern pattern = Pattern.compile("(?<action>\\+|-)(?<ip>\\d{1,3}(?:.\\d{1,3}){3})#(?<s1>\\d+)#(?<s2>\\d+)#(?<category>\\w+(?:\\s+\\w+)?)#(?:.+)#(?:.+)#(?:.+)#(?:\\d+)");

                        while ((inputLine = bufferedReader.readLine()) != null) {
                            Matcher match = pattern.matcher(inputLine);

                            if (match.matches()) {

                                String ip = match.group("ip");
                                Key key = new Key(namespace, collection, ip);

                                if(match.group("action").equals("-")){
                                    aerospikeClient.put(writePolicy, key, new Bin("rt_otx",0));
                                }else{
                                    Map<String, Object> ipScores = new HashMap<>();

                                    int calculatedScore = Integer.valueOf(match.group("s1")) * Integer.valueOf(match.group("s2")) * 2;
                                    Long maxScore = Long.MIN_VALUE;

                                    Record record = aerospikeClient.get(new Policy(), key);

                                    Long sectionScore = -1L;
                                    Long globalScore = -1L;

                                    if (record != null) {
                                        ipScores.putAll(record.bins);
                                        ipScores.put("rt_otx", calculatedScore);
                                    } else {
                                        ipScores.put("ip", ip);
                                        ipScores.put("rt_otx", calculatedScore);
                                        ipScores.put("category", match.group("category"));
                                    }


                                    for (Map.Entry<String, Object> field : ipScores.entrySet())
                                        if (field.getKey().matches("rt_\\w+")) {
                                            Double score = Double.valueOf(field.getValue().toString());
                                            Double weight = Double.valueOf(specificWeights.containsKey(field.getKey()) ? specificWeights.get(field.getKey()).toString() : "0.0");

                                            if (score > 0) {
                                                if (sectionScore < 0) sectionScore = 0L;
                                                sectionScore += Double.valueOf(score * weight).longValue();
                                            }

                                            if (score > maxScore)
                                                maxScore = score.longValue();
                                        }


                                    ipScores.put("g_rt_score", sectionScore);

                                    for (Map.Entry<String, Object> field : ipScores.entrySet()) {
                                        if (field.getKey().matches("g_\\w+") && field.getKey().contains("score")) {
                                            Double localScore = Double.valueOf(field.getValue().toString());
                                            Double weight = Double.valueOf(specificWeights.containsKey(field.getKey()) ? specificWeights.get(field.getKey()).toString() : "0.0");

                                            if (localScore >= 0) {
                                                if (globalScore < 0) globalScore = 0L;
                                                globalScore += Double.valueOf(localScore * weight).longValue();
                                            }
                                        }
                                    }

                                    ipScores.put("score", globalScore);

                                    if (calculatedScore > maxScore)
                                        ipScores.put("category", match.group("category"));

                                    for (Map.Entry<String, Object> bins : ipScores.entrySet()) {
                                        aerospikeClient.put(writePolicy, key, new Bin(bins.getKey(), bins.getValue()));
                                    }
                                }

                            }

                        }

                        bufferedReader.close();
                        conn.getInputStream().close();

                    }

                    status = Status.UPDATED;
                    log.trace("Current status : UPDATED");
                }

            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
