package net.redborder.malware.modules.data;

import com.aerospike.client.Host;
import com.aerospike.client.Key;
import com.aerospike.client.Record;
import com.aerospike.client.async.AsyncClient;
import com.aerospike.client.async.AsyncClientPolicy;
import com.aerospike.client.policy.Policy;
import com.aerospike.client.policy.QueryPolicy;
import com.aerospike.client.policy.RecordExistsAction;
import com.aerospike.client.policy.WritePolicy;
import com.aerospike.client.query.KeyRecord;
import com.aerospike.client.query.RecordSet;
import com.aerospike.client.query.Statement;
import com.rits.cloning.Cloner;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

public class AeroSpikeDataModule extends AbstractDataModule {

    private static final Logger log = LoggerFactory.getLogger(AeroSpikeDataModule.class);

    private AsyncClient aerospikeClient;
    private List<String> hosts;
    Integer timeout;
    WritePolicy writePolicy;
    private String collection = null;
    private String namespace = null;
    private String value;

    private ArrayList<Map<String, Object>> lastIncremental = new ArrayList<>();

    public AeroSpikeDataModule(Config conf) throws ConfigException {
        super(conf);

        this.hosts = config.getList("aerospike.servers");
        this.timeout = config.getInt("aerospike.clientTimeout", 500);
        this.collection = config.get("aerospike.collection", "rb_malware");
        this.namespace = config.get("aerospike.namespace", "malware");
        this.writePolicy = new WritePolicy();
        this.writePolicy.recordExistsAction = RecordExistsAction.UPDATE;
    }

    @Override
    public Object getFullDataImpl() {

        log.trace("Getting full data from AeroSpike client");

        ArrayList<Map<String, Object>> result = new ArrayList<>();


        if (fullDataType.compareTo(FullDataType.TOTAL) != 0) {

            Statement stmt = new Statement();
            stmt.setNamespace(namespace);

            log.trace("Getting {} full data", fullDataType.value.toUpperCase());
            stmt.setSetName(String.format("%sScores", fullDataType.value));

            RecordSet records = aerospikeClient.query(new QueryPolicy(), stmt);

            if (records == null) {
                this.finalResult = new ArrayList<Map<String, Object>>();
                return this.finalResult;
            } else {

                Set<String> retainKeys = new HashSet<>();
                retainKeys.add("score");
                retainKeys.add(fullDataType.value);

                while (records.next()) {
                    Map<String, Object> record = records.getRecord().bins;

                    if(record.containsKey("list_type")) {
                        String list_type = record.get("list_type").toString();

                        if (list_type.matches("black")){
                            record.put("score", -3);
                        }else if(list_type.matches("white")){
                            record.put("score", -2);
                        }

                    }

                    record.keySet().retainAll(retainKeys);

                    if(record.keySet().containsAll(retainKeys))
                        result.add(record);

                }

                this.finalResult = result;

                return this.finalResult;

            }

        } else {
            log.trace("Getting TOTAL full data");

            for (FullDataType value : FullDataType.values()) {

                if (value.compareTo(FullDataType.TOTAL) != 0) {

                    Statement stmt = new Statement();
                    stmt.setNamespace(namespace);

                    log.trace("Getting total for : {}", value.value);

                    stmt.setSetName(String.format("%sScores", value.value));

                    RecordSet records = aerospikeClient.query(new QueryPolicy(), stmt);

                    log.trace("Processing total result ...");

                    if (records != null) {
                        Iterator<KeyRecord> it = records.iterator();

                        Set<String> retainKeys = new HashSet<>();
                        retainKeys.add("score");
                        retainKeys.add(value.value);

                        while (it.hasNext()) {
                            Map<String, Object> record = it.next().record.bins;

                            if(record.containsKey("list_type")) {
                                String list_type = record.get("list_type").toString();

                                if (list_type.matches("black")){
                                    record.put("score", -3);
                                }else if(list_type.matches("white")){
                                    record.put("score", -2);
                                }

                            }

                            record.keySet().retainAll(retainKeys);

                            if(record.keySet().containsAll(retainKeys))
                                result.add(record);
                        }
                    } else {
                        result = new ArrayList<>();
                    }

                    log.trace("Getted total for : {}", value.value);
                }
            }

            log.trace("Getted full data!");

            finalResult = result;

            return finalResult;
        }

    }

    @Override
    public Object getIncrementalImpl() {

        Cloner cloner = new Cloner();

        fullDataType = FullDataType.TOTAL;
        // Getting full database
        ArrayList<Map<String, Object>> fullList = (ArrayList<Map<String, Object>>) getFullDataImpl();
        log.trace("Getted full list size: {}", fullList.size());
        ArrayList<Map<String, Object>> delta = cloner.deepClone(fullList);

//        System.out.println("FULL LIST : " + fullList);
        log.trace("Getted full list incremental size : {}", delta.size());

        if(lastIncremental == null)
            lastIncremental = new ArrayList<>();

//        System.out.println("DELTA BEFORE : " + delta);

//        System.out.println("LAST INCREMENTAL : " + lastIncremental);

        delta.removeAll(lastIncremental);

//        System.out.println("DELTA : " + delta);

        ArrayList<Map<String, Object>> keyes = cloner.deepClone(delta);

        for(Map<String, Object> filteredIncremental: keyes)
            filteredIncremental.keySet().retainAll(Arrays.asList("hash", "ip", "url"));

//        System.out.println("FILTERED : " + keyes);



        log.trace("Getted full list incremental difference size : {}", delta.size());

        lastIncremental = cloner.deepClone(fullList);

        log.trace("Getted full list last incremental size : {}", lastIncremental.size());

        finalResult = delta;

        return finalResult;
    }

    @Override
    public void prepareQueryImpl(Object parameter) {
        value = parameter.toString();
    }

    @Override
    public void initImpl() {
        log.trace("Initializing AeroSpike Data Module");
    }

    @Override
    public void shutdownImpl() {
        log.trace("Shutdown AeroSpike data module ...");
        if (aerospikeClient.isConnected())
            aerospikeClient.close();
        log.trace("Done!");
    }

    @Override
    public void reloadImpl() {
        List<Host> servers = new ArrayList<>();

        for (String host : hosts) {
            String[] sp = host.split(":");
            servers.add(new Host(sp[0], Integer.valueOf(sp[1])));
        }

        AsyncClientPolicy cPolicy = new AsyncClientPolicy();
        cPolicy.timeout = timeout;

        aerospikeClient = new AsyncClient(cPolicy, servers.toArray(new Host[servers.size()]));
        log.trace(String.format("AeroSpike connected to %s", servers));
    }

    @Override
    public String getDataModuleName() {
        return "AeroSpike";
    }

    @Override
    public Map<String, Object> processQueryURL(String URL) {

        Map<String, Object> result = new HashMap<>();

        log.trace("Getting data from AeroSpike client");

        Record record = aerospikeClient.get(new Policy(), new Key(namespace, "urlScores", URL));

        if (record == null) {
            result.put("record", new HashMap<String, Object>());
            return result;
        } else {
            result.put("record", record.bins);
            return result;
        }
    }

    @Override
    public Map<String, Object> processQueryHash(String hash) {

        Map<String, Object> result = new HashMap<>();

        log.trace("Getting data from AeroSpike client");

        Record record = aerospikeClient.get(new Policy(), new Key(namespace, "hashScores", hash));

        if (record == null) {
            result.put("record", new HashMap<String, Object>());
            return result;
        } else {
            result.put("record", record.bins);
            return result;
        }
    }

    @Override
    public Map<String, Object> processQueryIP(String IP) {

        Map<String, Object> result = new HashMap<>();

        log.trace("Getting data from AeroSpike client");

        Record record = aerospikeClient.get(new Policy(), new Key(namespace, collection, IP));

        if (record == null) {
            result.put("record", new HashMap<String, Object>());
            return result;
        } else {
            result.put("record", record.bins);
            return result;
        }
    }

}
