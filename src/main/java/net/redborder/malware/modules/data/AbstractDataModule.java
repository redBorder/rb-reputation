package net.redborder.malware.modules.data;

import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.CountDownLatch;

public abstract class AbstractDataModule implements DataModule {

    private static final Logger log = LoggerFactory.getLogger(AbstractDataModule.class);

    public enum Status {
        NOT_INITIALIZATE, READY, PROCESSING, FINISHED, ERROR
    }

    protected Status status;

    // Config file
    protected Config config;

    // Flag for continue
    protected CountDownLatch latch;

    // Selected operation
    protected volatile Operation operation;

    protected volatile FullDataType fullDataType;

    protected Object finalResult;

    protected Map<String, Object> proxy;

    private Set<String> paramsFilter;

    private Map<String, Object> parametersForQuery;

    public AbstractDataModule(Config conf) {

        this.config = conf;
        status = Status.NOT_INITIALIZATE;

        paramsFilter = new HashSet<>();
        proxy = new HashMap<>();
        fullDataType = FullDataType.TOTAL;

        // Create the filter
        for (QUERY_PARAM constants : QUERY_PARAM.values())
            paramsFilter.add(constants.value);

    }

    @Override
    public void selectOperation(Operation operation) {
        this.operation = operation;
    }

    @Override
    public void selectFullDataType(FullDataType fullDataType) {
        this.fullDataType = fullDataType;
    }

    @Override
    public void prepareQuery(Map<String, Object> parameters) {

        log.trace("Preparing query for module {}", getDataModuleName());
        parameters.keySet().retainAll(paramsFilter);
        log.trace("Parameters for query : {}", parameters);
        parametersForQuery = parameters;

        prepareQueryImpl(parametersForQuery);

    }

    @Override
    public void init() {
        initImpl();
        reload();
        status = Status.READY;
    }

    @Override
    public Object getFullData() {
        log.trace("Get full data from {}", getDataModuleName());
        finalResult = getFullDataImpl();

        if (latch != null) {
            latch.countDown();
            log.trace("{} : Remaining counts {}", getDataModuleName(), latch.getCount());
            latch = null;
        }

        return finalResult;
    }

    @Override
    public Object getIncremental() {
        log.info("Get incremental from {}", getDataModuleName());
        finalResult = getIncrementalImpl();

        if (latch != null) {
            latch.countDown();
            log.info("{} : Remaining counts {}", getDataModuleName(), latch.getCount());
            latch = null;
        }

        return finalResult;
    }

    @Override
    public Object doQuery() {

        log.info("Doing query for module {}", getDataModuleName());
        log.trace("with parameters {}", parametersForQuery);

        ArrayList<Map<String, Object>> results = new ArrayList<>();

        for (Map.Entry<String, Object> parameter : parametersForQuery.entrySet()) {
            log.trace("Doing query for {} with value {}", parameter.getKey(), parameter.getValue());
            switch (QUERY_PARAM.valueOf(parameter.getKey().toUpperCase())) {
                case HASH:
                    if (parameter.getValue() instanceof ArrayList) {
                        // Nothing to do
                    } else {
                        results.add(processQueryHash(parameter.getValue().toString()));
                    }
                    break;
                case IP:
                    if (parameter.getValue() instanceof ArrayList) {
                        // Nothing to do
                    } else {
                        results.add(processQueryIP(parameter.getValue().toString()));
                    }
                    break;
                case URL:
                    if (parameter.getValue() instanceof ArrayList) {
                        //Nothing to do
                    } else {
                        results.add(processQueryURL(parameter.getValue().toString()));
                    }
                    break;
            }
        }

        finalResult = results;

        if (latch != null) {
            latch.countDown();
            log.trace("{} : Remaining counts {}", getDataModuleName(), latch.getCount());
            latch = null;
        }

        return results;
    }

    @Override
    public void shutdown() {
        log.trace("Shutting down {}", getDataModuleName());
        shutdownImpl();
        log.trace("Shutdown!");
    }

    @Override
    public void run() {

        status = Status.PROCESSING;

        switch (operation) {
            case FULL:
                finalResult = getFullData();
                break;
            case QUERY:
                finalResult = doQuery();
                break;
            case INCREMENTAL:
                finalResult = getIncremental();
                break;
        }

        status = Status.FINISHED;
    }

    @Override
    public Object getOperationResult() {
        return finalResult;
    }

    @Override
    public void addLatch(CountDownLatch latch) {
        this.latch = latch;
        log.trace("Added latch with {} counts", latch.getCount());
    }

    @Override
    public void reload() {
        try {

            if (config.getProperties().contains("malware.proxy")) {
                String[] proxyHost = config.get("malware.proxy").split(":");
                proxy.put("ip", proxyHost[0]);
                proxy.put("port", proxyHost[1]);
            }

        } catch (ConfigException e) {
            e.printStackTrace();
        }

        reloadImpl();

    }

    public abstract Object getFullDataImpl();

    public abstract Object getIncrementalImpl();

    public abstract void prepareQueryImpl(Object parameter);

    public abstract void initImpl();

    public abstract void shutdownImpl();

    public abstract void reloadImpl();


}
