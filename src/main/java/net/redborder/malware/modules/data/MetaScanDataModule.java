package net.redborder.malware.modules.data;

import com.fasterxml.jackson.databind.ObjectMapper;
import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MetaScanDataModule extends AbstractDataModule {

    private static final Logger log = LoggerFactory.getLogger(MetaScanDataModule.class);

    private String apiKey;
    private final String lookupHASH = "http://hashlookup.metascan-online.com/v2/hash/%s";
    private final String lookupIP = "https://ipscan.metascan-online.com/v1/scan/%s";
    private ObjectMapper mapper;
    private Map<String, Object> proxy;
    private String value;

    public MetaScanDataModule(Config conf) {
        super(conf);

    }

    @Override
    public Object getFullDataImpl() {
        finalResult = new ArrayList<Map<String, Object>>();
        return finalResult;
    }

    @Override
    public Object getIncrementalImpl() {
        finalResult = new ArrayList<Map<String, Object>>();
        return finalResult;
    }

    @Override
    public void prepareQueryImpl(Object parameter) {
        value = parameter.toString();
    }

    @Override
    public void initImpl() {

        mapper = new ObjectMapper();

        try {
            apiKey = config.get("metascan.apikey");

            if (config.getProperties().contains("metascan.proxy")) {
                String[] proxy = config.get("metascan.proxy").split(":");
                this.proxy.put("ip", proxy[0]);
                this.proxy.put("port", Integer.parseInt(proxy[1]));
            } else {
                this.proxy = new HashMap<>();
            }
        } catch (ConfigException e) {
            e.printStackTrace();
        }

    }

    @Override
    public void shutdownImpl() {
    }

    @Override
    public String getDataModuleName() {
        return "MetaScan";
    }

    @Override
    public Map<String, Object> processQueryURL(String URL) {
        Map<String, Object> finalResult = new HashMap<>();
        finalResult.put("url", URL);

        HttpURLConnection conn;
        Proxy prox = null;

        int responseCode;

        if (!proxy.isEmpty()) {
            log.info("Using proxy");
            prox = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(String.valueOf(proxy.get("ip")), (Integer) proxy.get("port")));
        }

        try {
            URL objLookup = new URL(String.format(lookupIP, URL));

            if (prox == null)
                conn = (HttpURLConnection) objLookup.openConnection();
            else
                conn = (HttpURLConnection) objLookup.openConnection(prox);

            conn.setRequestMethod("GET");
            conn.setRequestProperty("apikey", apiKey);

            responseCode = conn.getResponseCode();

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuffer response = new StringBuffer();
            String inputLine;

            while ((inputLine = bufferedReader.readLine()) != null) {
                response.append(inputLine);
            }


            switch (responseCode) {
                case 400:
                    log.info("CODE 400 Bad Request - Unsupported HTTP method or invalid HTTP request (e.g., empty body)");
                    break;
                case 401:
                    log.info("CODE 401 Invalid API key - Either missing API key or invalid API is passed.");
                    break;
                case 403:
                    log.info("CODE 403 Signature lookup limit reached, try again later - The hourly hash lookup limit has been reached for this API key.");
                    break;
                case 503:
                    log.info("CODE 503 Internal Server Error - Server temporarily unavailable. Try again later.");
                    break;
                case 200:
                    log.info("CODE 200 Petition completed");

                    if (!response.toString().contains("IP/URI is null or empty")) {
                        log.info("Found results!");

                        Map<String, Object> fileJson = mapper.readValue(response.toString(), Map.class);
                        List<Map<String, Object>> scans = (List<Map<String, Object>>) fileJson.get("scan_results");

                        Long detected = 0L;
                        Long total = scans.size() == 0 ? 1L : scans.size();

                        for (Map<String, Object> engines : scans) {

                            List<Map<String, Object>> results = (List<Map<String, Object>>) engines.get("results");

                            for (Map<String, Object> result : results) {

                                String value = result.get("result").toString();

                                switch (value) {
                                    case "blacklisted":
                                        detected++;
                                        total++;
                                        break;
                                    case "whitelisted":
                                        total++;
                                        break;
                                }

                            }
                        }
                        int value = (int) (detected * 100 / total);
                        finalResult.put("score", (value) == 0 ? -1 : value);

                        return finalResult;
                    } else {
                        finalResult.put("score", -1);
                        log.info("Result not found");

                        return finalResult;
                    }
            }

        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public Map<String, Object> processQueryHash(String hash) {
        Map<String, Object> finalResult = new HashMap<>();
        finalResult.put("hash", hash);

        HttpURLConnection conn;
        Proxy prox = null;

        int responseCode;

        if (!proxy.isEmpty()) {
            log.info("Using proxy");
            prox = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(String.valueOf(proxy.get("ip")), (Integer) proxy.get("port")));
        }

        try {
            URL objLookup = new URL(String.format(lookupHASH, hash));
            if (prox == null)
                conn = (HttpURLConnection) objLookup.openConnection();
            else
                conn = (HttpURLConnection) objLookup.openConnection(prox);

            conn.setRequestMethod("GET");
            conn.setRequestProperty("apikey", apiKey);

            responseCode = conn.getResponseCode();

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuffer response = new StringBuffer();
            String inputLine;

            while ((inputLine = bufferedReader.readLine()) != null) {
                response.append(inputLine);
            }

            bufferedReader.close();

            switch (responseCode) {
                case 400:
                    log.info("CODE 400 Bad Request - Unsupported HTTP method or invalid HTTP request (e.g., empty body)");
                    break;
                case 401:
                    log.info("CODE 401 Invalid API key - Either missing API key or invalid API is passed.");
                    break;
                case 403:
                    log.info("CODE 403 Signature lookup limit reached, try again later - The hourly hash lookup limit has been reached for this API key.");
                    break;
                case 200:
                    log.info("CODE 200 Petition completed");

                    if (!response.toString().contains("Not Found")) {
                        log.info("Found results!");

                        Map<String, Object> fileJson = mapper.readValue(response.toString(), Map.class);
                        Map<String, Object> scans = (Map<String, Object>) ((Map<String, Object>) fileJson.get("scan_results")).get("scan_details");

                        Long detected = 0L;
                        Long total = scans.size() == 0 ? 1L : scans.size();

                        for (String engineName : scans.keySet()) {
                            Map<String, Object> scan = (Map<String, Object>) scans.get(engineName);

                            String result = scan.get("threat_found").equals("") ? "N/A" : (String) scan.get("threat_found");

                            if (!result.equals("N/A")) {
                                detected++;
                            }
                        }

                        finalResult.put("score", detected * 100 / total);

                        return finalResult;
                    } else {
                        finalResult.put("score", -1);
                        log.info("Result not found");

                        return finalResult;
                    }
            }

        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public Map<String, Object> processQueryIP(String IP) {
        Map<String, Object> finalResult = new HashMap<>();
        finalResult.put("ip", IP);

        HttpURLConnection conn;
        Proxy prox = null;

        int responseCode;

        if (!proxy.isEmpty()) {
            log.info("Using proxy");
            prox = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(String.valueOf(proxy.get("ip")), (Integer) proxy.get("port")));
        }

        try {
            URL objLookup = new URL(String.format(lookupIP, IP));

            if (prox == null)
                conn = (HttpURLConnection) objLookup.openConnection();
            else
                conn = (HttpURLConnection) objLookup.openConnection(prox);

            conn.setRequestMethod("GET");
            conn.setRequestProperty("apikey", apiKey);

            responseCode = conn.getResponseCode();

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuffer response = new StringBuffer();
            String inputLine;

            while ((inputLine = bufferedReader.readLine()) != null) {
                response.append(inputLine);
            }

            bufferedReader.close();

            switch (responseCode) {
                case 400:
                    log.info("CODE 400 Bad Request - Unsupported HTTP method or invalid HTTP request (e.g., empty body)");
                    break;
                case 401:
                    log.info("CODE 401 Invalid API key - Either missing API key or invalid API is passed.");
                    break;
                case 403:
                    log.info("CODE 403 Signature lookup limit reached, try again later - The hourly hash lookup limit has been reached for this API key.");
                    break;
                case 503:
                    log.info("CODE 503 Internal Server Error - Server temporarily unavailable. Try again later.");
                    break;
                case 200:
                    log.info("CODE 200 Petition completed");

                    if (!response.toString().contains("IP/URI is null or empty")) {
                        log.info("Found results!");

                        Map<String, Object> fileJson = mapper.readValue(response.toString(), Map.class);
                        List<Map<String, Object>> scans = (List<Map<String, Object>>) fileJson.get("scan_results");

                        Long detected = 0L;
                        Long total = scans.size() == 0 ? 1L : scans.size();

                        for (Map<String, Object> engines : scans) {

                            List<Map<String, Object>> results = (List<Map<String, Object>>) engines.get("results");

                            for (Map<String, Object> result : results) {

                                String value = result.get("result").toString();

                                switch (value) {
                                    case "blacklisted":
                                        detected++;
                                        total++;
                                        break;
                                    case "whitelisted":
                                        total++;
                                        break;
                                }

                            }
                        }
                        int value = (int) (detected * 100 / total);
                        finalResult.put("score", (value) == 0 ? -1 : value);

                        return finalResult;
                    } else {
                        finalResult.put("score", -1);
                        log.info("Result not found");

                        return finalResult;
                    }
            }

        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }
}
