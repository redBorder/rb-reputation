package net.redborder.malware.modules.data;

import net.redborder.malware.config.Config;
import net.redborder.malware.config.ConfigException;
import net.redborder.malware.utils.HTTP;
import net.redborder.malware.utils.IPUtils;

import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class MetaScanDataModule extends AbstractDataModule {

    private static final Logger log = LoggerFactory.getLogger(MetaScanDataModule.class);

    private String apiKey;
    private final String lookupHASH = "https://api.metadefender.com/v4/hash/%s";
    private final String lookupIP = "https://api.metadefender.com/v4/ip/%s";
    private final String lookupURL = "https://api.metadefender.com/v4/url/%s";
    
    public MetaScanDataModule(Config conf) {
        super(conf);

    }

    @Override
    public Object getFullDataImpl() {
        finalResult = new ArrayList<Map<String, Object>>();
        return finalResult;
    }

    @Override
    public Object getIncrementalImpl() {
        finalResult = new ArrayList<Map<String, Object>>();
        return finalResult;
    }

    @Override
    public void prepareQueryImpl(Object parameter) {
        parameter.toString();
    }

    @Override
    public void initImpl() {
        log.trace("Initializing MetaDefender data module");
    }

    @Override
    public void shutdownImpl() {

    }

    @Override
    public void reloadImpl() {

        try {
            apiKey = config.get("metascan.apikey");
        } catch (ConfigException e) {
            log.error(e.getLocalizedMessage());
        }


    }

    @Override
    public String getDataModuleName() {
        return "MetaScan";
    }
    
    /**
     * Method to get url, ip or hash malware score using Metadefender API. 
     * @param queryObject String with the url, ip or hash to analyze.
     * @param queryParameter String with the type of object. It must be one of the aforementioned objects.  
     * @param lookup URL with the API's direction. 
     * @return Object's analyzed score. If something went wrong, returns -1.
     */
    public int getScore(String queryObject, String queryParameter, String lookup) {
    	
    	
    	if (queryParameter.equals("IP")){
    		if (IPUtils.isPrivateNetwork(queryObject)) {
    			log.info("Private IP");
    			return 0;
    		}
    	}
    	
    	// Setting https protocols
    	System.setProperty("https.protocols", "TLSv1.1,TLSv1.2,SSLv3,SSLv2Hello");
    	
    	int score = -1;
        HttpURLConnection conn;
        Proxy prox = null;

        int responseCode;

        if (!proxy.isEmpty()) {
            log.info("Using proxy");
            prox = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(String.valueOf(proxy.get("ip")), (Integer) proxy.get("port")));
        }

        try {

            URL objLookup = new URL(String.format(lookup, HTTP.removeProtocolFromURL(queryObject)));
            
            if (prox == null)
            	conn = (HttpURLConnection) objLookup.openConnection();
            else
            	conn = (HttpURLConnection) objLookup.openConnection(prox);
            
            conn.setRequestMethod("GET");
            conn.setRequestProperty("apikey", apiKey);
            
            responseCode = conn.getResponseCode();

            switch (responseCode) {
	            case 400:
	                log.info("CODE 400 Bad Request - Unsupported HTTP method or invalid HTTP request (e.g., empty body)");
	                break;
	            case 401:
	                log.info("CODE 401 Invalid API key - Either missing API key or invalid API is passed.");
	                break;
	            case 403:
	                log.info("CODE 403 Signature lookup limit reached, try again later - The hourly hash lookup limit has been reached for this API key.");
	                break;
	            case 404:
	                log.info("CODE 404 Bad Request - URL cannot be found.");
	                break;
	            case 503:
	                log.info("CODE 503 Internal Server Error - Server temporarily unavailable. Try again later.");
	                break;
	            case 200:
	                log.info("CODE 200 Petition completed");
	
	                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
	                StringBuffer response = new StringBuffer();
	                String inputLine;
	
	                while ((inputLine = bufferedReader.readLine()) != null) {
	                    response.append(inputLine);
	                }
	
	                bufferedReader.close();
	                JSONObject json = new JSONObject(response.toString());
	                JSONObject json2;
	                int total = 0;
	                int detected = 0;
	                
	                switch (queryParameter.toUpperCase()) {
		                case "URL":
		                case "IP":
		                	json2 = ((JSONObject) json.get("lookup_results"));
		                    
		                    total = ((JSONArray) json2.get("sources")).length();
		                    
		                    detected = (int) json2.get("detected_by");
		                    
		                    break;
		                    
		                case "HASH":
		                	json2 = ((JSONObject) json.get("scan_results"));
		                    
		                    total = (int) json2.get("total_avs");
		                    
		                    detected = (int) json2.get("total_detected_avs");
		                }
	                score = detected * 100 / total;
	    		} 
            }
        catch (java.io.IOException ex)  {log.error(ex.getLocalizedMessage());}
        catch (NumberFormatException ex){log.error(ex.getLocalizedMessage());}

	    return score;
    }

    @Override
    public Map<String, Object> processQueryURL(String URL) {

        int score;
        
		score = getScore(URL, "URL", lookupURL);

        Map<String, Object> finalResult = new HashMap<>();
        finalResult.put("url", URL);

        finalResult.put("score", score);

        return finalResult;
    }

    @Override
    public Map<String, Object> processQueryHash(String hash) {

    	int score;
        
		score = getScore(hash, "HASH", lookupHASH);

        Map<String, Object> finalResult = new HashMap<>();
        finalResult.put("hash", hash);

        finalResult.put("score", score);

        return finalResult;
    }

    @Override
    public Map<String, Object> processQueryIP(String IP) {

    	int score;
        
		score = getScore(IP, "IP", lookupIP);

        Map<String, Object> finalResult = new HashMap<>();
        finalResult.put("ip", IP);

        finalResult.put("score", score);

        return finalResult;
    }
}
