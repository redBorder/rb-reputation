package net.redborder.malware.modules.data;

import net.redborder.malware.config.Config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class LocalCacheDataModule extends AbstractDataModule {

    private static final Logger log = LoggerFactory.getLogger(LocalCacheDataModule.class);

    // Queue for data
    private LinkedBlockingQueue<Map<String, Object>> queue;
    // ArrayList with all JSONs
    private ArrayList<Map<String, Object>> totalList = null;
    // ArrayList with current JSONs
    private ArrayList<Map<String, Object>> revisionList = null;
    // Map of revisions
    private Map<String, ArrayList<Map<String, Object>>> mapOfRevisions = new HashMap<>();
    // Executor Service for threads
    private ExecutorService executorService;

    // Condition for consumer thread
    private boolean read = false;

    // Current revision
    private int revision = 0;
    // Number of enable revisions
    private int OFFSET = 2;

    public int getCurrentRevisionNumber(){
        return revision;
    }

    public LocalCacheDataModule(Config conf) {
        super(conf);

        OFFSET = config.getInt("malware.localcache.offset", 2);

        this.revisionList = new ArrayList<>();
        registerOnMap(revisionList);
        this.totalList = new ArrayList<>();

    }

    public void startContinuousQuery() {
        if (executorService == null)
            executorService = Executors.newSingleThreadExecutor();

        read = true;
        executorService.submit(new ReadFromQueue());
    }

    public void stopContinuousQuery() {
        read = false;
        executorService.shutdown();
    }


    public void createAndRegisterNewRevision(ArrayList<Map<String, Object>> newRevision, int revisionNumber) {
        revision = revisionNumber;
        revisionList = newRevision;

        registerOnMap(revisionList);
    }

    public void createNewRevision() {
        revisionList = new ArrayList<Map<String, Object>>();
    }


    private void registerOnMap(ArrayList<Map<String, Object>> revisionList) {
        mapOfRevisions.put(String.format("revision%d", revision), revisionList);

        if (mapOfRevisions.size() > OFFSET) {
            log.info("Deleted revision : {}", (revision - OFFSET));
            mapOfRevisions.remove(String.format("revision%d", revision - OFFSET));
        }
    }

    public void createTotal(ArrayList<Map<String, Object>> total) {
        this.totalList = total;
    }

    public void createTotal(){
        this.totalList = new ArrayList<>();
    }

    public ArrayList<Map<String, Object>> getRevNum(int numRev) {
        String key = String.format("revision%d", numRev);
        return mapOfRevisions.containsKey(key) ? mapOfRevisions.get(key) : null;
    }

    public ArrayList<Map<String, Object>> getCurrentRevision() {

        if (revisionList == null)
            revisionList = new ArrayList<>();

        return revisionList;
    }

    @Override
    public void init() {

    }

    @Override
    public Object query(String hash) {
        return null;
    }

    @Override
    public Object getFullData() {

        if (totalList == null)
            totalList = new ArrayList<>();

        return totalList;    }

    @Override
    public Object getIncremental() {
        return null;
    }

    @Override
    public void shutdown() {

    }

    @Override
    public void clearData() {

    }

    @Override
    public void update() {

    }

    private class ReadFromQueue implements Runnable {

        @Override
        public void run() {
            try {
                while(read) {
                    revisionList.add(queue.take());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
